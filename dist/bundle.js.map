{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/Polarbear.ts","src/attributes/Bindval.ts","src/attributes/Events.ts","src/attributes/Loopfor.ts","src/data/DataFns.ts","src/data/Observe.ts","src/dom/Traverse.ts","src/etc/ElementEvents.ts","src/etc/KeyCodes.ts","src/etc/NormalizeString.ts","src/etc/Regexes.ts","src/etc/ResolveType.ts","src/parser/CodeParser.ts","src/vdom/CreateElement.ts","src/vdom/Diff.ts","src/vdom/Hydrate.ts","src/vdom/Render.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Traverse_1","Observe_1","ElementEvents_1","Render_1","Diff_1","Hydrate_1","Polarbear","prototype","render","r1","performance","now","this","$initial","$currentVDom","default","$masterVDom","console","log","$appEl","$node","$target","replaceWith","mount","renderElem","$appContainerEl","temp","patch","r2","toFixed","params","$refs","$filters","$data","$watchers","created","$appContainerSel","el","document","querySelector","data","methods","method","hasOwnProperty","events","event_1","possibleEventList","includes","addEventListener","filters","filter","watch","prop","mounted","window","DataFns_1","instance","modifiers","eventName","returnAsNumber","trimReturnValue","fn","elementValue","target","value","isNaN","parseFloat","trim","setProp","KeyCodes_1","CodeParser_1","event","callbackFn","eventComponents","split","eventModifiers","splice","commonKeyCodeNames","Object","keys","keyCodes","otherEventModifiers","capture","passive","prevent","once","conditionalChecks","forEach","em","push","parsedModifier","Number","conditionalRule","join","finalCode","parse","Function","ResolveType_1","NormalizeString_1","statement","loopComponents","specifics","iterable","getProp","keyName","valName","idxName","count","type","entries","parseInt","obj","val","x","l","indexOf","key","def","undefined","observe","parent","propPath_1","propertyVal","valueType","constructor","Array","arrProxy","Proxy","deleteProperty","property","String","set","definitionLocation","defineProperty","get","v","oldVal","apply","Regexes_1","CreateElement_1","traverse","node","attrs","conditionalCase","loopCase","boundData","refName","children","from","childNodes","nodeType","attributes","_a","name_1","name","startsWith","slice","opts","replace","Regexes","interpolationContent","s","previousElementSibling","tagName","backspace","delete","down","enter","left","right","space","tab","up","esc","interpolation","globalInterpolation","innerInterpolation","innerFunctionInterpolation","filterMatch","filter2Match","filterNames","toString","isArray","func","functionName","substr","_b","_c","_d","_e","_f","_g","_h","diffChildren","oldVChildren","newVChildren","childPatches","oldVChild","diff","additionalPatches","additionalVChild","appendChild","_i","$parent","xs","ys","zipped","Math","max","zip","child","additionalPatches_1","vOldNode","vNewNode","remove","$newNode","$newNode_1","parentNode","patchAttrs","oldAttrs","newAttrs","patches","k","setAttribute","removeAttribute","patches_1","diffAttrs","patchChildren","Loopfor_1","hydrate","extraData","nodeCopy","JSON","stringify","newRootChildren","map","tagName_1","attrs_1","events_1","conditionalCase_1","boundData_1","refName_1","children_1","keyName_1","valName_1","idxName_1","iterable_1","type_1","newChildren","j","parsed","computeContent","content","interpolationMatches","match","cur","Events_1","Bindval_1","conditionalEval","Boolean","createComment","$el","createElement","_j","_k","_l","$child","HTMLInputElement","_m","vNode","createTextNode"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import traverse from \"./dom/Traverse\";\nimport observe from \"./data/Observe\";\nimport { possibleEventList } from \"./etc/ElementEvents\";\nimport { renderElem } from \"./vdom/Render\";\nimport diff from \"./vdom/Diff\";\nimport hydrate from \"./vdom/Hydrate\";\n\ntype funcProp = { [key: string]: Function };\n\ninterface PolarbearParams {\n  created?: Function; // Instance created lifecycle hook\n  data?: { [key: string]: any }; // Instance data properties\n  el?: string; // App container element selector\n  events?: funcProp; // Global document events\n  filters?: funcProp; // Content interpolation filters\n  methods?: funcProp; // Instance methods\n  mounted?: Function; // Instance mounted lifecycle hook\n  watch?: funcProp; // Property watchers\n}\n\nexport default class Polarbear {\n  // Root app container selector\n  $appContainerSel: string;\n\n  // Root app container element\n  $appContainerEl: HTMLElement;\n\n  // Virtual dom\n  $masterVDom: any;\n  $currentVDom: any;\n\n  // References to document elements that are used for edge cases\n  $refs: { [key: string]: Element } = {};\n\n  // Filter functions for use with interpolation elements\n  $filters: funcProp = {};\n\n  // Data properties for instance\n  $data: { [key: string]: any } = {};\n\n  // Property watchers for calling functions on property changes\n  $watchers: { [key: string]: Function } = {};\n\n  // Allows for other instance properties to be created\n  [key: string]: any;\n\n  // TODO: remove\n  $initial: boolean = true;\n\n  $appEl: HTMLElement;\n\n  constructor(params: PolarbearParams) {\n    // Call created method if it exists\n    // Instance has just been created. Nothing else has happened yet\n    if (params.created) params.created();\n\n    // Get app container selector so that it may be continuous referenced for mounting\n    this.$appContainerSel = params.el;\n\n    // Grab root app element\n    this.$appContainerEl = document.querySelector(this.$appContainerSel);\n\n    // Traverse app DOM and copy into VDOM\n    this.$masterVDom = traverse(this.$appContainerEl);\n    this.$currentVDom = {};\n\n    // Create observables for all of the data attributes\n    observe(this, params.data);\n\n    // Migrate methods to root level of instance so that they may be easily used\n    if (params.methods) {\n      for (const method in params.methods) {\n        if (params.methods.hasOwnProperty(method)) {\n          // Remap created methods to root level\n          this[method] = params.methods[method];\n        }\n      }\n    }\n\n    // Initialize all document level events if they exist\n    if (params.events) {\n      for (const event in params.events) {\n        if (params.events.hasOwnProperty(event) && possibleEventList.includes(event)) {\n          // Add document level event callbacks for chosen events\n          // TODO: probably change this to be on the app container rather than document\n          document.addEventListener(event, (e: Event) => params.events[event](e));\n        }\n      }\n    }\n\n    // Copy over filter functions into instance\n    if (params.filters) {\n      for (const filter in params.filters) {\n        if (params.filters.hasOwnProperty(filter)) {\n          // Copy filter to the instance\n          this.$filters[filter] = params.filters[filter];\n        }\n      }\n    }\n\n\n    // Perform initial render\n    this.render();\n\n    // Initialize property watchers\n    if (params.watch) {\n      for (const prop in params.watch) {\n        if (params.watch.hasOwnProperty(prop)) {\n          // Copy the watcher's callback function to the instance\n          this.$watchers[prop] = params.watch[prop];\n        }\n      }\n    }\n\n    // Call mounted method if it exists\n    // Instance has finished generation\n    if (params.mounted) params.mounted.call(this);\n  }\n\n  render() {\n    const r1 = performance.now();\n    if (this.$initial) {\n      this.$currentVDom = hydrate(this, this.$masterVDom);\n\n      console.log(this.$currentVDom);\n\n      this.$appEl = mount(renderElem(this, this.$currentVDom), this.$appContainerEl);\n\n      this.$initial = false;\n    } else {\n      const temp = hydrate(this, this.$masterVDom);\n\n      console.log(temp);\n\n      const patch = diff(this, this.$currentVDom, temp);\n\n      this.$appEl = patch(this.$appEl);\n\n      this.$currentVDom = temp;\n    }\n\n    const r2 = performance.now();\n    console.log(`Render took ${(r2 - r1).toFixed(1)}ms`);\n  }\n}\n\nfunction mount($node: HTMLElement, $target: HTMLElement) {\n  $target.replaceWith($node);\n  return $node;\n}\n\n(window as any).Polarbear = Polarbear;\n","import Polarbear from \"../Polarbear\";\nimport { setProp } from \"../data/DataFns\";\n\nexport default function computeBinding(instance: Polarbear, prop: string, modifiers: string[]) {\n  // Decide whether to bind the value on the element's input or change event\n  let eventName: string = \"input\";\n  if (modifiers.includes(\"lazy\")) eventName = \"change\";\n\n  // Decide whether to return the element's value as a number\n  let returnAsNumber: boolean = false;\n  if (modifiers.includes(\"number\")) returnAsNumber = true;\n\n  // Decide whether to trim the element's value\n  let trimReturnValue: boolean = false;\n  if (modifiers.includes(\"trim\")) trimReturnValue = true;\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Retrieve element value from event's target element\n      let elementValue: any = (e.target as HTMLInputElement).value;\n\n      // Parse value to number if the bindval has 'number' flag\n      elementValue = returnAsNumber ? isNaN(parseFloat(elementValue)) ? elementValue : parseFloat(elementValue) : elementValue;\n\n      // Trim string if the bindval has 'trim' flag\n      elementValue = trimReturnValue ? elementValue.trim() : elementValue;\n\n      // Update the property on the instance\n      setProp(instance, prop, elementValue);\n    }\n  };\n}\n","import Polarbear from \"../Polarbear\";\nimport { keyCodes } from \"../etc/KeyCodes\";\nimport { possibleEventList } from \"../etc/ElementEvents\";\nimport { parse } from \"../parser/CodeParser\";\n\nexport default function computeEvent(instance: Polarbear, event: string, callbackFn: string): any {\n  // Split raw event into its name and possible modifiers\n  const eventComponents: string[] = event.split(\".\");\n\n  const eventName: string = eventComponents[0];\n  const eventModifiers: string[] = eventComponents.splice(1);\n\n  // Check for valid event name before attempting to add it to an element\n  if (!possibleEventList.includes(eventName)) {\n    // ERROR: invalid event name\n    return;\n  }\n\n  // Get list of common keys that we want to reference by name instead of keycodes\n  const commonKeyCodeNames: string[] = Object.keys(keyCodes);\n\n  // Get the list of other event modifiers that we want to check for\n  const otherEventModifiers: { [key: string]: boolean } = {\n    \"capture\": false,\n    \"passive\": false,\n    \"prevent\": false,\n    \"once\": false\n  };\n\n  // List of conditional evaluations that will be joined together to check within the event callback\n  let conditionalChecks: (string | number)[] = [];\n\n  // Iterate over event modifiers and compute their responsibility\n  eventModifiers.forEach((em: string) => {\n    if (Object.keys(otherEventModifiers)\n              .includes(em)) {\n      // Change modifier to true if it is a present modifier\n      otherEventModifiers[em] = true;\n    } else if (commonKeyCodeNames.includes(em)) {\n      // Add the resolved key-code value to the conditional checks\n      conditionalChecks.push(`$event.keyCode === ${keyCodes[em]}`);\n    } else {\n      // Attempt to convert the modifier to a number\n      const parsedModifier: number = Number(em);\n      if (!isNaN(parsedModifier)) {\n        // If the modifier is a valid number, add it as a key-code conditional check\n        conditionalChecks.push(`$event.keyCode === ${parsedModifier}`);\n      } else {\n        // If not then just add the literal key value to a key conditional check\n        conditionalChecks.push(`$event.key === '${em}'`);\n      }\n    }\n  });\n\n  // Create a conditional string to evaluate within the function call before evaluating actual code\n  const conditionalRule: string = `if (!(${conditionalChecks.join(\"||\")})) { return; }`;\n\n  // Parse the received code into usable code for the event listener\n  const finalCode: string = parse(instance, callbackFn);\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Create strict evaluated function call\n      return Function(`\n      \"use strict\";\n      const $event = arguments[0];\n      ${otherEventModifiers[\"prevent\"] ? `$event.preventDefault();` : \"\"}\n      ${conditionalChecks.length > 0 ? conditionalRule : \"\"}\n      ${finalCode}\n      `)\n        .call(instance, e);\n    },\n    otherEventModifiers\n  };\n}\n","import Polarbear from \"../Polarbear\";\nimport { getProp } from \"../data/DataFns\";\nimport resolveType from \"../etc/ResolveType\";\nimport normalizeString from \"../etc/NormalizeString\";\n\nexport default function computeLoop(instance: Polarbear, statement: string) {\n  const loopComponents: string[] = statement.split(/\\sin\\s/);\n\n  if (loopComponents.length > 1) {\n    const specifics = loopComponents[0].trim()\n                                       .split(\",\");\n    let iterable = getProp(instance.$data, loopComponents[1].trim()) || loopComponents[1].trim();\n\n    let keyName, valName, idxName, count;\n\n    const type = resolveType(iterable);\n\n    if (specifics.length === 1) {\n      keyName = normalizeString(specifics[0]);\n    } else if (specifics.length === 2) {\n      keyName = normalizeString(specifics[0]);\n      idxName = normalizeString(specifics[1]);\n    } else if (specifics.length === 3) {\n      keyName = normalizeString(specifics[0]);\n      valName = normalizeString(specifics[1]);\n      idxName = normalizeString(specifics[2]);\n    } else {\n      // ERROR: too many vars\n    }\n\n    switch (type) {\n      case \"array\":\n        count = iterable.length;\n        break;\n      case \"object\":\n        iterable = Object.entries(iterable);\n        count = Object.keys(iterable).length;\n        break;\n      case \"number\":\n        // TODO: implement number iterable\n        count = parseInt(iterable);\n        break;\n      default:\n        // ERROR: unknown iterable type\n        break;\n    }\n\n    return {\n      keyName,\n      valName,\n      idxName,\n      iterable,\n      count,\n      type\n    };\n  } else {\n    // ERROR: invalid loop specification\n  }\n}\n","type contiguousObj = { [key: string]: any }\n\n// https://github.com/lukeed/dset\nexport const setProp = (obj: contiguousObj, keys: (string | string[]), val: any): void => {\n  (keys as string).split && (keys = (keys as string).split(\".\"));\n  let i = 0, l = keys.length, t = obj, x;\n  for (; i < l; ++i) {\n    x = t[keys[i]];\n    t = t[keys[i]] = (i === l - 1 ? val : (x != null ? x : (!!~keys[i + 1].indexOf(\".\") || !(+keys[i + 1] > -1)) ? {} : []));\n  }\n};\n\n// https://github.com/developit/dlv\nexport const getProp = (obj: contiguousObj, key: (string | string[]), def?: any, p?: number): any => {\n  p = 0;\n  key = (key as string).split ? (key as string).split(\".\") : key;\n  while (obj && p < key.length) obj = obj[key[p++]];\n  return (obj === undefined || p < key.length) ? def : obj;\n};\n","import Polarbear from \"../Polarbear\";\nimport { getProp, setProp } from \"./DataFns\";\n\nexport default function observe(instance: Polarbear, obj: { [key: string]: any }, parent?: string): void {\n  for (const prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      // Remap property path if it is a nested property\n      const propPath = parent ? `${parent}.${prop}` : prop;\n\n      // Retrieve property value from its original object\n      const propertyVal = getProp(obj, prop);\n\n      // Get the literal type of the retrieved property\n      const valueType = propertyVal.constructor;\n\n      if (valueType === Object) {\n        // Set property to be empty object since its children will need to be separately observed\n        setProp(instance.$data, propPath, {});\n        setProp(instance, propPath, {});\n\n        // Observe child properties of object\n        observe(instance, propertyVal, propPath);\n      } else if (valueType === Array) {\n        // Store reference array in instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // TODO: update list components if arrays are updated\n\n        const arrProxy = new Proxy(getProp(instance.$data, propPath), {\n          // Proxy trap for value deletion\n          deleteProperty(target: any, property: any): boolean {\n            console.log(`deleting ${String(property)} from ${target}`);\n            return true;\n          },\n          // Proxy trap for updating or adding values\n          set(target: any, property: any, value: any): boolean {\n            target[property] = value;\n            console.log(`${target} ${value} ${String(property)}`);\n            return true;\n          }\n        });\n\n        // Set array proxy to actual root property so that proxy traps are triggered on property reference\n        setProp(instance, propPath, arrProxy);\n      } else {\n        // Store reference property on instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // Set property on root of instance or on child object of instance root\n        const definitionLocation = parent ? getProp(instance, parent) : instance;\n\n        // Define property getters and setters on instance\n        Object.defineProperty(definitionLocation, prop, {\n          get(): any {\n            // Retrieve value from alternative reference so that there is not an infinite loop\n            return getProp(instance.$data, propPath);\n          },\n          set(v: any): void {\n            // Get the property's previous value before reassigning it\n            const oldVal = getProp(instance.$data, propPath);\n            // Set alternative reference so that there is not an infinite loop\n            setProp(instance.$data, propPath, v);\n            // Now that the value has been updated we want to call the watcher if it exists\n            if (instance.$watchers[propPath]) {\n              // Pass through the instance reference and the property's old value and new value\n              instance.$watchers[propPath].apply(instance, [oldVal, v]);\n            }\n            // Update conditionally rendered elements based on property changes\n            // TODO\n            // Call render functions for all components that use the updated property\n            // TODO\n            instance.render();\n          }\n        });\n      }\n    }\n  }\n};\n","import { Regexes } from \"../etc/Regexes\";\nimport createEl from \"../vdom/CreateElement\";\nimport { strObj, vNode } from \"../globals\";\n\nexport default function traverse(node: HTMLElement) {\n  let attrs: strObj = {};\n  let events: strObj = {};\n  let conditionalCase: string = \"\";\n  let loopCase: string = \"\";\n  let boundData: { [key: string]: any } = {};\n  let refName: string = \"\";\n  let children: vNode[] = [];\n\n  Array.from(node.childNodes)\n       .forEach((e: HTMLElement) => {\n         if (e.nodeType === 1) {\n           children.push((traverse(e) as vNode));\n         } else {\n           children.push((e as any).data);\n         }\n       });\n\n  for (let i = 0; i < node.attributes.length; i++) {\n    const {name, value} = node.attributes[i];\n\n    if (name.startsWith(\"@\")) {\n      // Process event attributes\n      const ev = name.slice(1);\n      events[ev] = value;\n    } else if (name.startsWith(\"bindval\")) {\n      // Process value binding attribute\n      const specs = name.split(\".\");\n      boundData = {\n        prop: value,\n        opts: specs.slice(1)\n      };\n    } else if (name === \"loopfor\") {\n      // Process loop attribute\n      loopCase = String(value);\n    } else if (name === \"ref\") {\n      // Process reference attribute\n      refName = String(value);\n    } else if (name === \"showif\") {\n      // Process conditional if attribute\n      const computedCondition: string = value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = computedCondition;\n    } else if (name === \"showelse\") {\n      // Process conditional else attribute\n      // @ts-ignore\n      const computedCondition: string = node.previousElementSibling.attributes[\"showif\"].value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = `!(${computedCondition})`;\n    } else {\n      // Found no matching attributes related to Polarbear\n      attrs[name] = value;\n    }\n  }\n\n  return createEl(node.tagName, {\n    attrs,\n    events,\n    conditionalCase,\n    loopCase,\n    boundData,\n    refName,\n    children\n  });\n};\n","// https://developer.mozilla.org/en-US/docs/Web/Events\nexport const possibleEventList: string[] = [\n  \"input\",\n  \"change\",\n  \"cached\",\n  \"error\",\n  \"abort\",\n  \"load\",\n  \"beforeunload\",\n  \"unload\",\n  \"online\",\n  \"offline\",\n  \"focus\",\n  \"blur\",\n  \"animationstart\",\n  \"animationend\",\n  \"animationiteration\",\n  \"transitionstart\",\n  \"transitioncancel\",\n  \"transitionend\",\n  \"transitionrun\",\n  \"reset\",\n  \"submit\",\n  \"resize\",\n  \"scroll\",\n  \"cut\",\n  \"copy\",\n  \"paste\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mouseenter\",\n  \"mouseover\",\n  \"mousemove\",\n  \"mousedown\",\n  \"mouseup\",\n  \"auxclick\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"wheel\",\n  \"mouseleave\",\n  \"mouseout\",\n  \"select\",\n  \"dragstart\",\n  \"drag\",\n  \"dragend\",\n  \"dragenter\",\n  \"dragover\",\n  \"dragleave\",\n  \"drop\",\n  \"durationchange\",\n  \"loadedmetadata\",\n  \"loadeddata\",\n  \"canplay\",\n  \"canplaythrough\",\n  \"ended\",\n  \"emptied\",\n  \"stalled\",\n  \"suspend\",\n  \"play\",\n  \"playing\",\n  \"pause\",\n  \"waiting\",\n  \"seeking\",\n  \"seeked\",\n  \"ratechange\",\n  \"timeupdate\",\n  \"volumechange\",\n  \"complete\",\n  \"audioprocess\"\n];","// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\nexport const keyCodes: { [key: string]: number } = {\n  \"backspace\": 8,\n  \"delete\": 46,\n  \"down\": 40,\n  \"enter\": 13,\n  \"left\": 37,\n  \"right\": 39,\n  \"space\": 32,\n  \"tab\": 9,\n  \"up\": 38,\n  \"esc\": 27\n};","/*\n * Strips whitespace and removes any characters besides alphanumeric characters, '$', '_'\n * */\nexport default function normalizeString(s: string): string {\n  return s.replace(/[^A-z0-9_$]/g, \"\")\n          .trim();\n}\n","export namespace Regexes {\n  /*\n   * Matches interpolation content (mustache syntax)\n   *\n   * Input:\n   * `Some content with interpolation content... {{age + 10}}. Some other content {{favColor}}`\n   *\n   * Match:\n   * {{age + 10}}\n   */\n  export const interpolation: RegExp = /({{.*?}})/;\n\n  /*\n   * Matches all mustache syntax interpolation within a string\n   * rather than the first occurrence found\n   *\n   * Input:\n   * `Team 1 score: {{score1}}. Team 2 score: {{score2}}.`\n   *\n   * Matches:\n   * {{score1}}\n   * {{score2}}\n   */\n  export const globalInterpolation: RegExp = /({{.*?}})/g;\n\n  /*\n   * Matches first found property or function inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello\n   */\n  export const innerInterpolation: RegExp = /[\\w\\.]+/;\n\n  /*\n   * Matches only functions in inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello()\n   */\n  export const innerFunctionInterpolation: RegExp = /\\w+\\(\\)/;\n\n  /*\n   * Matches function calls inside interpolation matches\n   *\n   * Input:\n   * `console.log(name + ' is cool. Their age is: ' + age)`\n   *\n   * Matches:\n   * console.log\n   * name\n   * age\n   */\n  export const interpolationContent: RegExp = /[A-z]+((\\.\\w+)+)?(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n\n  /*\n   * Matches filters in interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name | upper | reverse}}`\n   *\n   * Matches:\n   * | upper | reverse\n   */\n  export const filterMatch: RegExp = /(\\|)(\\s+)?\\w+(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filter2Match: RegExp = /(\\|)(\\s+)?\\w+(\\.\\w+)?(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filterNames: RegExp = /\\w+(\\.\\w+)?/g;\n\n  // export const funcParseReg: RegExp = /([$\\w.]+?(?=\\())(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n  // export const propParseReg: RegExp = /\\w+(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n}","/*\n * Resolves a variable type\n * */\nexport default function resolveType(o: any): string {\n  if (o !== undefined && o.toString() === \"[object Object]\") {\n    return \"object\";\n  } else if (Array.isArray(o)) {\n    return \"array\";\n  } else if (!isNaN(o + 0)) {\n    return \"number\";\n  } else {\n    return \"string\";\n  }\n}\n","import Polarbear from \"../Polarbear\";\nimport { Regexes } from \"../etc/Regexes\";\n\nexport const parse = (instance: Polarbear, code: string): string => {\n  return code.replace(Regexes.innerFunctionInterpolation, (func): string => {\n    // Strip parenthesis from function name to check if the function is in the instance\n    const functionName: string = func.substr(0, func.length - 2);\n\n    if (instance[functionName]) {\n      // Return usable function call if function exists in instance\n      return `this.${func}`;\n    } else {\n      // Return original function call if function is not related to instance\n      return func;\n    }\n  });\n};\n","import { vNodeOpts } from \"../globals\";\n\nexport default function createEl(tagName: string, {attrs = {}, events = {}, conditionalCase = \"\", loopCase = \"\", boundData = {}, refName = \"\", children = []}: vNodeOpts) {\n  return {\n    tagName,\n    attrs,\n    events,\n    conditionalCase,\n    loopCase,\n    boundData,\n    refName,\n    children\n  };\n}\n","/*\n * Code adapted from: https://github.com/ycmjason-talks/2018-11-21-manc-web-meetup-4\n * */\n\nimport Polarbear from \"../Polarbear\";\nimport { vNode } from \"../globals\";\nimport { render, renderElem } from \"./Render\";\nimport createEl from \"./CreateElement\";\n\nconst zip = (xs: (vNode | string)[], ys: ((vNode | string)[] | NodeListOf<ChildNode>)) => {\n  const zipped = [];\n  for (let i = 0; i < Math.max(xs.length, ys.length); i++) {\n    zipped.push([xs[i], ys[i]]);\n  }\n  return zipped;\n};\n\nconst diffAttrs = (oldAttrs: {}, newAttrs: {}) => {\n  const patches: any[] = [];\n\n  // set new attributes\n  for (const [k, v] of Object.entries(newAttrs)) {\n    patches.push(($node: HTMLElement) => {\n      $node.setAttribute(k, (v as any));\n      return $node;\n    });\n  }\n\n  // remove old attributes\n  for (const k in oldAttrs) {\n    if (!(k in newAttrs)) {\n      patches.push(($node: HTMLElement) => {\n        $node.removeAttribute(k);\n        return $node;\n      });\n    }\n  }\n\n  return ($node: HTMLElement) => {\n    for (const patch of patches) {\n      patch($node);\n    }\n  };\n};\n\nconst diffChildren = (instance: Polarbear, oldVChildren: (vNode | string)[], newVChildren: (vNode | string)[]) => {\n  const childPatches: any[] = [];\n  oldVChildren.forEach((oldVChild: (vNode | string), i: number) => {\n    childPatches.push(diff(instance, oldVChild, newVChildren[i]));\n  });\n\n  const additionalPatches: any[] = [];\n  for (const additionalVChild of newVChildren.slice(oldVChildren.length)) {\n    additionalPatches.push(($node: HTMLElement) => {\n      $node.appendChild(render(instance, additionalVChild));\n      return $node;\n    });\n  }\n\n  return ($parent: HTMLElement) => {\n    for (const [patch, child] of zip(childPatches, $parent.childNodes)) {\n      if (patch !== undefined && child !== undefined) {\n        (patch as any)(child);\n      }\n    }\n\n    for (const patch of additionalPatches) {\n      patch($parent);\n    }\n\n    return $parent;\n  };\n};\n\nexport default function diff(instance: Polarbear, vOldNode: (vNode | string), vNewNode: (vNode | string)) {\n  if (vNewNode === undefined) {\n    return ($node: HTMLElement): undefined => {\n      $node.remove();\n      return undefined;\n    };\n  }\n\n  if (typeof vOldNode === \"string\" ||\n    typeof vNewNode === \"string\") {\n    if (vOldNode !== vNewNode) {\n      return ($node: HTMLElement) => {\n        const $newNode = render(instance, vNewNode);\n        $node.replaceWith($newNode);\n        return $newNode;\n      };\n    } else {\n      return ($node: HTMLElement): undefined => undefined;\n    }\n  }\n\n  if (vOldNode.tagName !== vNewNode.tagName) {\n    return ($node: HTMLElement) => {\n      const $newNode = render(instance, vNewNode);\n      $node.replaceWith($newNode);\n      return $newNode;\n    };\n  }\n\n  if (vNewNode.conditionalCase !== \"\") {\n    // TODO: compare to previous evaluation\n    return ($node: HTMLElement) => {\n      const $newNode = render(instance, vNewNode);\n      $node.replaceWith($newNode);\n      return $newNode;\n    };\n  }\n\n  if (vNewNode.loopCase !== vOldNode.loopCase) {\n    // TODO: this should probably be cleaned up\n    const $newNode = renderElem(instance, createEl(vNewNode.tagName, {\n      attrs: undefined, boundData: {}, conditionalCase: \"\", events: undefined, loopCase: undefined, refName: \"\",\n      children: render(instance, vNewNode)\n    }));\n    return ($node: HTMLElement) => {\n      for (let i = $node.parentNode.childNodes.length - 1; i > 1; i--) {\n        $node.parentNode.childNodes[i].remove();\n      }\n      $node.replaceWith($newNode);\n      return $newNode;\n    };\n  }\n\n  const patchAttrs = diffAttrs(vOldNode.attrs, vNewNode.attrs);\n  const patchChildren = diffChildren(instance, vOldNode.children, vNewNode.children);\n\n  return ($node: HTMLElement) => {\n    if ($node.nodeType === 1) {\n      patchAttrs($node);\n      patchChildren($node);\n    }\n    return $node;\n  };\n};\n","import { vNode } from \"../globals\";\nimport Polarbear from \"../Polarbear\";\nimport { Regexes } from \"../etc/Regexes\";\nimport createEl from \"./CreateElement\";\nimport computeLoop from \"../attributes/Loopfor\";\nimport { getProp } from \"../data/DataFns\";\nimport resolveType from \"../etc/ResolveType\";\n\nexport default function hydrate(instance: Polarbear, node: (vNode | string), extraData?: { [key: string]: any }) {\n  const nodeCopy = JSON.parse(JSON.stringify(node));\n  const data = instance.$data;\n\n  let newRootChildren: (vNode | string)[] = [];\n\n  nodeCopy.children.map((e: (vNode | string)) => {\n    if (typeof e !== \"string\" && e.loopCase) {\n      const {tagName, attrs = {}, events = {}, conditionalCase, loopCase, boundData, refName, children = []} = e;\n\n      const {keyName, valName, idxName, iterable, count, type} = computeLoop(instance, loopCase);\n\n      const newChildren = Array.from(new Array(count), (v, j) => {\n        return createEl(tagName, {\n          attrs,\n          events,\n          conditionalCase,\n          loopCase: null,\n          boundData,\n          refName: null,\n          // TODO: only re-hydrate the nodes if their data has changed or the loop iteration has changed\n          children: [hydrate(instance, {\n            tagName, attrs, events, conditionalCase, loopCase: null, boundData, refName, children\n          }, {\n            [keyName || '$KEYNAME']: type === \"array\" ? iterable[j]: type === \"object\" ? iterable[j][0] : j,\n            [valName || '$VALNAME']: type === \"array\" ? null: type === \"object\" ? iterable[j][1]: j,\n            [idxName || '$IDXNAME']: j\n          })]\n        });\n      });\n\n      newRootChildren.push(...newChildren);\n    } else {\n      if (resolveType(e) === \"object\") {\n        newRootChildren.push(hydrate(instance, e as vNode, extraData));\n      } else {\n        const parsed = computeContent(instance, e as string);\n\n        newRootChildren.push(Function(`\n            \"use strict\";\n            const $EXTRA_DATA = arguments[0];\n            return \\`${parsed}\\`;\n            `)\n          .call(data, extraData || {}));\n      }\n    }\n  });\n\n  nodeCopy.children = newRootChildren;\n\n  return nodeCopy;\n}\n\nconst computeContent = (instance: Polarbear, content: string) => {\n  // Attempt to find interpolation calls within an elements text content\n  const interpolationMatches: RegExpMatchArray = content.match(Regexes.globalInterpolation);\n\n  // If there is no interpolation calls then just break out\n  if (!interpolationMatches) {\n    return content;\n  }\n\n  for (let i = 0; i < interpolationMatches.length; i++) {\n    // Replace every interpolation call with its computed evaluation\n    content = content.replace(interpolationMatches[i], (cur: string) => {\n      // Replace each property or function call within the interpolation with a reference to the instance\n      const innerContent = cur.replace(Regexes.interpolationContent, (s: string) => {\n        if (getProp(instance.$data, s) !== undefined) {\n          return `this.${s}`;\n        } else {\n          return `$EXTRA_DATA.${s}`;\n        }\n      });\n\n      return innerContent.replace(\"{{\", \"${\")\n                         .replace(\"}}\", \"}\");\n    });\n  }\n\n  return content;\n};\n","import Polarbear from \"../Polarbear\";\nimport { vNode } from \"../globals\";\nimport computeEvent from \"../attributes/Events\";\nimport { getProp } from \"../data/DataFns\";\nimport computeBinding from \"../attributes/Bindval\";\n\nexport const renderElem = (instance: Polarbear, {tagName, attrs = {}, events = {}, conditionalCase, boundData, refName, children = []}: vNode): any => {\n  // Evaluate conditional statement for the element\n  const conditionalEval: boolean = Boolean(Function(`\"use strict\";return ${conditionalCase};`)\n    .call(instance));\n\n  // Create a comment element if the conditional statement is false\n  if (conditionalCase && conditionalEval === false) {\n    return document.createComment(\" \");\n  }\n\n  // Create a base element with specified tag type\n  const $el = document.createElement(tagName);\n\n  // Add element attributes\n  for (const [k, v] of Object.entries(attrs)) {\n    $el.setAttribute(k, v);\n  }\n\n  // Add element events\n  for (const [k, v] of Object.entries(events)) {\n    const {eventName, fn, otherEventModifiers} = computeEvent(instance, k, v);\n    $el.addEventListener(eventName, fn, otherEventModifiers);\n  }\n\n  // Render and append element children\n  for (const child of children) {\n    const $child = render(instance, child);\n    $el.appendChild($child);\n  }\n\n  if (boundData && $el instanceof HTMLInputElement) {\n    const {prop, opts} = boundData;\n\n    $el.value = getProp(instance, prop);\n\n    const {eventName, fn} = computeBinding(instance, prop, opts);\n    $el.addEventListener(eventName, fn);\n  }\n\n  if (refName) {\n    instance.$refs[refName] = $el;\n  }\n\n  // Return the created element\n  return $el;\n};\n\nexport const render = (instance: Polarbear, vNode: vNode | string): any => {\n  if (typeof vNode === \"string\") {\n    return document.createTextNode(vNode);\n  }\n  return renderElem(instance, vNode);\n};\n"]}