{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/Polarbear.ts","src/attributes/Events.ts","src/data/DataFns.ts","src/data/Observe.ts","src/dom/Traverse.ts","src/etc/ElementEvents.ts","src/etc/KeyCodes.ts","src/etc/Regexes.ts","src/parser/CodeParser.ts","src/vdom/CreateElement.ts","src/vdom/Render.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Traverse_1","Observe_1","ElementEvents_1","Render_1","Polarbear","prototype","render","document","querySelector","this","$appContainerSel","replaceWith","renderElem","$vdom","params","$refs","$filters","$data","$watchers","created","el","$appContainerEl","traverse","observe","data","methods","method","hasOwnProperty","events","event_1","possibleEventList","includes","addEventListener","filters","filter","watch","prop","mounted","window","KeyCodes_1","CodeParser_1","default","instance","event","callbackFn","eventComponents","split","eventName","eventModifiers","splice","commonKeyCodeNames","Object","keys","keyCodes","otherEventModifiers","capture","passive","prevent","once","conditionalChecks","forEach","em","push","parsedModifier","Number","isNaN","conditionalRule","join","finalCode","parse","fn","Function","setProp","obj","val","x","l","indexOf","getProp","key","def","undefined","DataFns_1","parent","propPath_1","propertyVal","valueType","constructor","Array","arrProxy","Proxy","deleteProperty","target","property","console","log","String","set","value","definitionLocation","defineProperty","get","v","oldVal","apply","Regexes_1","CreateElement_1","node","children","attrs","conditionalCase","from","childNodes","nodeType","attributes","_a","name_1","name","startsWith","slice","replace","Regexes","interpolationContent","s","previousElementSibling","createEl","tagName","backspace","delete","down","enter","left","right","space","tab","up","esc","interpolation","globalInterpolation","innerInterpolation","innerFunctionInterpolation","filterMatch","filter2Match","filterNames","func","functionName","substr","_b","_c","_d","_e","Events_1","conditionalEval","Boolean","createComment","$el","createElement","_i","entries","k","setAttribute","_f","_g","_h","children_1","child","$child","appendChild","vNode","createTextNode"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import { traverse } from \"./dom/Traverse\";\nimport { observe } from \"./data/Observe\";\nimport { possibleEventList } from \"./etc/ElementEvents\";\nimport { renderElem } from \"./vdom/Render\";\n\ntype funcProp = { [key: string]: Function };\n\ninterface PolarbearParams {\n  created?: Function; // Instance created lifecycle hook\n  data?: { [key: string]: any }; // Instance data properties\n  el?: string; // App container element selector\n  events?: funcProp; // Global document events\n  filters?: funcProp; // Content interpolation filters\n  methods?: funcProp; // Instance methods\n  mounted?: Function; // Instance mounted lifecycle hook\n  watch?: funcProp; // Property watchers\n}\n\nexport default class Polarbear {\n  // Root app container selector\n  $appContainerSel: string;\n\n  // Root app container element\n  $appContainerEl: HTMLElement;\n\n  // Virtual dom\n  $vdom: any;\n\n  // References to document elements that are used for edge cases\n  $refs: { [key: string]: Element } = {};\n\n  // Filter functions for use with interpolation elements\n  $filters: funcProp = {};\n\n  // Data properties for instance\n  $data: { [key: string]: any } = {};\n\n  // Property watchers for calling functions on property changes\n  $watchers: { [key: string]: Function } = {};\n\n  // Allows for other instance properties to be created\n  [key: string]: any;\n\n  constructor(params: PolarbearParams) {\n    // Call created method if it exists\n    // Instance has just been created. Nothing else has happened yet\n    if (params.created) params.created();\n\n    // Get app container selector so that it may be continuous referenced for mounting\n    this.$appContainerSel = params.el;\n\n    // Grab root app element\n    this.$appContainerEl = document.querySelector(this.$appContainerSel);\n\n    // Traverse app DOM and copy into VDOM\n    this.$vdom = traverse(this.$appContainerEl);\n\n    // Create observables for all of the data attributes\n    observe(this, params.data);\n\n    // Migrate methods to root level of instance so that they may be easily used\n    if (params.methods) {\n      for (const method in params.methods) {\n        if (params.methods.hasOwnProperty(method)) {\n          // Remap created methods to root level\n          this[method] = params.methods[method];\n        }\n      }\n    }\n\n    // Initialize all document level events if they exist\n    if (params.events) {\n      for (const event in params.events) {\n        if (params.events.hasOwnProperty(event) && possibleEventList.includes(event)) {\n          // Add document level event callbacks for chosen events\n          // TODO: probably change this to be on the app container rather than document\n          document.addEventListener(event, (e: Event) => params.events[event](e));\n        }\n      }\n    }\n\n    // Copy over filter functions into instance\n    if (params.filters) {\n      for (const filter in params.filters) {\n        if (params.filters.hasOwnProperty(filter)) {\n          // Copy filter to the instance\n          this.$filters[filter] = params.filters[filter];\n        }\n      }\n    }\n\n    // Perform initial render\n    this.render();\n\n    // Initialize property watchers\n    if (params.watch) {\n      for (const prop in params.watch) {\n        if (params.watch.hasOwnProperty(prop)) {\n          // Copy the watcher's callback function to the instance\n          this.$watchers[prop] = params.watch[prop];\n        }\n      }\n    }\n\n    // Call mounted method if it exists\n    // Instance has finished generation\n    if (params.mounted) params.mounted.call(this);\n  }\n\n  render() {\n    // Replace old DOM with newly rendered DOM\n    document.querySelector(this.$appContainerSel)\n            .replaceWith(renderElem(this, this.$vdom));\n  }\n}\n\n(window as any).Polarbear = Polarbear;\n","import Polarbear from \"../Polarbear\";\nimport { keyCodes } from \"../etc/KeyCodes\";\nimport { possibleEventList } from \"../etc/ElementEvents\";\nimport { parse } from \"../parser/CodeParser\";\n\nexport default function computeEvent(instance: Polarbear, event: string, callbackFn: string): any {\n  // Split raw event into its name and possible modifiers\n  const eventComponents: string[] = event.split(\".\");\n\n  const eventName: string = eventComponents[0];\n  const eventModifiers: string[] = eventComponents.splice(1);\n\n  // Get list of common keys that we want to reference by name instead of keycodes\n  const commonKeyCodeNames: string[] = Object.keys(keyCodes);\n\n  // Get the list of other event modifiers that we want to check for\n  const otherEventModifiers: { [key: string]: boolean } = {\n    \"capture\": false,\n    \"passive\": false,\n    \"prevent\": false,\n    \"once\": false\n  };\n\n  // List of conditional evaluations that will be joined together to check within the event callback\n  let conditionalChecks: (string | number)[] = [];\n\n  // Iterate over event modifiers and compute their responsibility\n  eventModifiers.forEach((em: string) => {\n    if (Object.keys(otherEventModifiers)\n              .includes(em)) {\n      // Change modifier to true if it is a present modifier\n      otherEventModifiers[em] = true;\n    } else if (commonKeyCodeNames.includes(em)) {\n      // Add the resolved key-code value to the conditional checks\n      conditionalChecks.push(`$event.keyCode === ${keyCodes[em]}`);\n    } else {\n      // Attempt to convert the modifier to a number\n      const parsedModifier: number = Number(em);\n      if (!isNaN(parsedModifier)) {\n        // If the modifier is a valid number, add it as a key-code conditional check\n        conditionalChecks.push(`$event.keyCode === ${parsedModifier}`);\n      } else {\n        // If not then just add the literal key value to a key conditional check\n        conditionalChecks.push(`$event.key === '${em}'`);\n      }\n    }\n  });\n\n  // Create a conditional string to evaluate within the function call before evaluating actual code\n  const conditionalRule: string = `if (!(${conditionalChecks.join(\"||\")})) { return; }`;\n\n  // Check for valid event name before attempting to add it to an element\n  if (!possibleEventList.includes(eventName)) {\n    // ERROR: invalid event name\n    return;\n  }\n\n  // Parse the received code into usable code for the event listener\n  const finalCode: string = parse(instance, callbackFn);\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Create strict evaluated function call\n      return Function(`\n      \"use strict\";\n      const $event = arguments[0];\n      ${otherEventModifiers[\"prevent\"] ? `$event.preventDefault();` : \"\"}\n      ${conditionalChecks.length > 0 ? conditionalRule : \"\"}\n      ${finalCode}\n      `)\n        .call(instance, e);\n    },\n    otherEventModifiers\n  };\n}\n","type contiguousObj = { [key: string]: any }\n\n// https://github.com/lukeed/dset\nexport const setProp = (obj: contiguousObj, keys: (string | string[]), val: any): void => {\n  (keys as string).split && (keys = (keys as string).split(\".\"));\n  let i = 0, l = keys.length, t = obj, x;\n  for (; i < l; ++i) {\n    x = t[keys[i]];\n    t = t[keys[i]] = (i === l - 1 ? val : (x != null ? x : (!!~keys[i + 1].indexOf(\".\") || !(+keys[i + 1] > -1)) ? {} : []));\n  }\n};\n\n// https://github.com/developit/dlv\nexport const getProp = (obj: contiguousObj, key: (string | string[]), def?: any, p?: number): any => {\n  p = 0;\n  key = (key as string).split ? (key as string).split(\".\") : key;\n  while (obj && p < key.length) obj = obj[key[p++]];\n  return (obj === undefined || p < key.length) ? def : obj;\n};\n","import Polarbear from \"../Polarbear\";\nimport { getProp, setProp } from \"./DataFns\";\n\nexport const observe = (instance: Polarbear, obj: { [key: string]: any }, parent?: string): void => {\n  for (const prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      // Remap property path if it is a nested property\n      const propPath = parent ? `${parent}.${prop}` : prop;\n\n      // Retrieve property value from its original object\n      const propertyVal = getProp(obj, prop);\n\n      // Get the literal type of the retrieved property\n      const valueType = propertyVal.constructor;\n\n      if (valueType === Object) {\n        // Set property to be empty object since its children will need to be separately observed\n        setProp(instance.$data, propPath, {});\n        setProp(instance, propPath, {});\n\n        // Observe child properties of object\n        observe(instance, propertyVal, propPath);\n      } else if (valueType === Array) {\n        // Store reference array in instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // TODO: update list components if arrays are updated\n\n        const arrProxy = new Proxy(getProp(instance.$data, propPath), {\n          // Proxy trap for value deletion\n          deleteProperty(target: any, property: any): boolean {\n            console.log(`deleting ${String(property)} from ${target}`);\n            return true;\n          },\n          // Proxy trap for updating or adding values\n          set(target: any, property: any, value: any): boolean {\n            target[property] = value;\n            console.log(`${target} ${value} ${String(property)}`);\n            return true;\n          }\n        });\n\n        // Set array proxy to actual root property so that proxy traps are triggered on property reference\n        setProp(instance, propPath, arrProxy);\n      } else {\n        // Store reference property on instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // Set property on root of instance or on child object of instance root\n        const definitionLocation = parent ? getProp(instance, parent) : instance;\n\n        // Define property getters and setters on instance\n        Object.defineProperty(definitionLocation, prop, {\n          get(): any {\n            // Retrieve value from alternative reference so that there is not an infinite loop\n            return getProp(instance.$data, propPath);\n          },\n          set(v: any): void {\n            // Get the property's previous value before reassigning it\n            const oldVal = getProp(instance.$data, propPath);\n            // Set alternative reference so that there is not an infinite loop\n            setProp(instance.$data, propPath, v);\n            // Now that the value has been updated we want to call the watcher if it exists\n            if (instance.$watchers[propPath]) {\n              // Pass through the instance reference and the property's old value and new value\n              instance.$watchers[propPath].apply(instance, [oldVal, v]);\n            }\n            // Update conditionally rendered elements based on property changes\n            // TODO\n            // Call render functions for all components that use the updated property\n            // TODO\n            instance.render();\n          }\n        });\n      }\n    }\n  }\n};\n","import { Regexes } from \"../etc/Regexes\";\nimport { createEl } from \"../vdom/CreateElement\";\n\nexport const traverse = (node: HTMLElement) => {\n  let children: {}[] = [];\n  let attrs: { [key: string]: string } = {};\n  let events: { [key: string]: string } = {};\n  let conditionalCase: string = \"\";\n\n  Array.from(node.childNodes)\n       .forEach((e: HTMLElement) => {\n         if (e.nodeType === 1) {\n           children.push(traverse(e));\n         } else {\n           children.push((e as any).data);\n         }\n       });\n\n  for (let i = 0; i < node.attributes.length; i++) {\n    const {name, value} = node.attributes[i];\n\n    if (name.startsWith(\"@\")) {\n      // Process event attributes\n      const ev = name.slice(1);\n      events[ev] = value\n    } else if (name.startsWith(\"bindval\")) {\n      // Process value binding attribute\n\n    } else if (name === \"loopfor\") {\n      // Process loop attribute\n\n    } else if (name === \"ref\") {\n      // Process reference attribute\n\n    } else if (name === \"showif\") {\n      // Process conditional if attribute\n      const computedCondition: string = value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = computedCondition;\n    } else if (name === \"showelse\") {\n      // Process conditional else attribute\n      // @ts-ignore\n      const computedCondition: string = node.previousElementSibling.attributes[\"showif\"].value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = `!(${computedCondition})`;\n    } else {\n      // Found no matching attributes related to Polarbear\n      attrs[name] = value;\n    }\n  }\n\n  return createEl(node.tagName, {\n    attrs,\n    events,\n    conditionalCase,\n    children\n  });\n};\n","// https://developer.mozilla.org/en-US/docs/Web/Events\nexport const possibleEventList: string[] = [\n  \"input\",\n  \"change\",\n  \"cached\",\n  \"error\",\n  \"abort\",\n  \"load\",\n  \"beforeunload\",\n  \"unload\",\n  \"online\",\n  \"offline\",\n  \"focus\",\n  \"blur\",\n  \"animationstart\",\n  \"animationend\",\n  \"animationiteration\",\n  \"transitionstart\",\n  \"transitioncancel\",\n  \"transitionend\",\n  \"transitionrun\",\n  \"reset\",\n  \"submit\",\n  \"resize\",\n  \"scroll\",\n  \"cut\",\n  \"copy\",\n  \"paste\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mouseenter\",\n  \"mouseover\",\n  \"mousemove\",\n  \"mousedown\",\n  \"mouseup\",\n  \"auxclick\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"wheel\",\n  \"mouseleave\",\n  \"mouseout\",\n  \"select\",\n  \"dragstart\",\n  \"drag\",\n  \"dragend\",\n  \"dragenter\",\n  \"dragover\",\n  \"dragleave\",\n  \"drop\",\n  \"durationchange\",\n  \"loadedmetadata\",\n  \"loadeddata\",\n  \"canplay\",\n  \"canplaythrough\",\n  \"ended\",\n  \"emptied\",\n  \"stalled\",\n  \"suspend\",\n  \"play\",\n  \"playing\",\n  \"pause\",\n  \"waiting\",\n  \"seeking\",\n  \"seeked\",\n  \"ratechange\",\n  \"timeupdate\",\n  \"volumechange\",\n  \"complete\",\n  \"audioprocess\"\n];","// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\nexport const keyCodes: { [key: string]: number } = {\n  \"backspace\": 8,\n  \"delete\": 46,\n  \"down\": 40,\n  \"enter\": 13,\n  \"left\": 37,\n  \"right\": 39,\n  \"space\": 32,\n  \"tab\": 9,\n  \"up\": 38,\n  \"esc\": 27\n};","export namespace Regexes {\n  /*\n   * Matches interpolation content (mustache syntax)\n   *\n   * Input:\n   * `Some content with interpolation content... {{age + 10}}. Some other content {{favColor}}`\n   *\n   * Match:\n   * {{age + 10}}\n   */\n  export const interpolation: RegExp = /({{.*?}})/;\n\n  /*\n   * Matches all mustache syntax interpolation within a string\n   * rather than the first occurrence found\n   *\n   * Input:\n   * `Team 1 score: {{score1}}. Team 2 score: {{score2}}.`\n   *\n   * Matches:\n   * {{score1}}\n   * {{score2}}\n   */\n  export const globalInterpolation: RegExp = /({{.*?}})/g;\n\n  /*\n   * Matches first found property or function inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello\n   */\n  export const innerInterpolation: RegExp = /[\\w\\.]+/;\n\n  /*\n   * Matches only functions in inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello()\n   */\n  export const innerFunctionInterpolation: RegExp = /\\w+\\(\\)/;\n\n  /*\n   * Matches function calls inside interpolation matches\n   *\n   * Input:\n   * `console.log(name + ' is cool. Their age is: ' + age)`\n   *\n   * Matches:\n   * console.log\n   * name\n   * age\n   */\n  export const interpolationContent: RegExp = /[A-z]+((\\.\\w+)+)?(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n\n  /*\n   * Matches filters in interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name | upper | reverse}}`\n   *\n   * Matches:\n   * | upper | reverse\n   */\n  export const filterMatch: RegExp = /(\\|)(\\s+)?\\w+(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filter2Match: RegExp = /(\\|)(\\s+)?\\w+(\\.\\w+)?(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filterNames: RegExp = /\\w+(\\.\\w+)?/g;\n\n  // export const funcParseReg: RegExp = /([$\\w.]+?(?=\\())(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n  // export const propParseReg: RegExp = /\\w+(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n}","import Polarbear from \"../Polarbear\";\nimport { Regexes } from \"../etc/Regexes\";\n\nexport const parse = (instance: Polarbear, code: string): string => {\n  return code.replace(Regexes.innerFunctionInterpolation, (func): string => {\n    // Strip parenthesis from function name to check if the function is in the instance\n    const functionName: string = func.substr(0, func.length - 2);\n\n    if (instance[functionName]) {\n      // Return usable function call if function exists in instance\n      return `this.${func}`;\n    } else {\n      // Return original function call if function is not related to instance\n      return func;\n    }\n  });\n};\n","type vNodeOpts = {\n  attrs: { [key: string]: string }\n  events: { [key: string]: string }\n  conditionalCase: string\n  children: {}[]\n}\n\nexport const createEl = (tagName: string, {attrs = {}, events = {}, conditionalCase = \"\", children = []}: vNodeOpts) => {\n  return {\n    tagName,\n    attrs,\n    events,\n    conditionalCase,\n    children\n  };\n};\n","import Polarbear from \"../Polarbear\";\nimport { vNode } from \"../globals\";\nimport computeEvent from \"../attributes/Events\";\nimport { Regexes } from \"../etc/Regexes\";\nimport innerInterpolation = Regexes.innerInterpolation;\n\nexport const renderElem = (instance: Polarbear, {tagName, attrs, events, conditionalCase, children}: vNode) => {\n  // Evaluate conditional statement for the element\n  const conditionalEval: boolean = Boolean(Function(`\"use strict\";return ${conditionalCase};`)\n    .call(instance));\n\n  // Create a comment element if the conditional statement is false\n  if (conditionalCase && conditionalEval === false) {\n    return document.createComment(\" \");\n  }\n\n  // Create a base element with specified tag type\n  const $el = document.createElement(tagName);\n\n  // Add element attributes\n  for (const [k, v] of Object.entries(attrs)) {\n    $el.setAttribute(k, v);\n  }\n\n  // Add element events\n  for (const [k, v] of Object.entries(events)) {\n    // $el.addEventListener(k, (v as any));\n    const { eventName, fn, otherEventModifiers } = computeEvent(instance, k, v);\n    $el.addEventListener(eventName, fn, otherEventModifiers);\n  }\n\n  // Render and append element children\n  for (const child of children) {\n    const $child = render(instance, child);\n    $el.appendChild($child);\n  }\n\n  // Return the created element\n  return $el;\n};\n\nconst render = (instance: Polarbear, vNode: vNode | string) => {\n  if (typeof vNode === \"string\") {\n    return document.createTextNode(vNode);\n  }\n  return renderElem(instance, vNode);\n};\n"]}