{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/Polarbear.ts","src/attributes/Bindval.ts","src/attributes/Events.ts","src/data/DataFns.ts","src/data/Observe.ts","src/dom/Traverse.ts","src/etc/ElementEvents.ts","src/etc/KeyCodes.ts","src/etc/Regexes.ts","src/parser/CodeParser.ts","src/vdom/CreateElement.ts","src/vdom/Render.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Traverse_1","Observe_1","ElementEvents_1","Render_1","Polarbear","prototype","render","r1","performance","now","document","querySelector","this","$appContainerSel","replaceWith","renderElem","$vdom","r2","console","log","toFixed","params","$refs","$filters","$data","$watchers","created","el","$appContainerEl","traverse","observe","data","methods","method","hasOwnProperty","events","event_1","possibleEventList","includes","addEventListener","filters","filter","watch","prop","mounted","window","DataFns_1","default","instance","modifiers","eventName","returnAsNumber","trimReturnValue","fn","elementValue","target","value","isNaN","parseFloat","trim","setProp","KeyCodes_1","CodeParser_1","event","callbackFn","eventComponents","split","eventModifiers","splice","commonKeyCodeNames","Object","keys","keyCodes","otherEventModifiers","capture","passive","prevent","once","conditionalChecks","forEach","em","push","parsedModifier","Number","conditionalRule","join","finalCode","parse","Function","obj","val","x","l","indexOf","getProp","key","def","undefined","parent","propPath_1","propertyVal","valueType","constructor","Array","arrProxy","Proxy","deleteProperty","property","String","set","definitionLocation","defineProperty","get","v","oldVal","apply","Regexes_1","CreateElement_1","node","attrs","conditionalCase","boundData","children","from","childNodes","nodeType","attributes","_a","name_1","name","startsWith","slice","opts","replace","Regexes","interpolationContent","s","previousElementSibling","createEl","tagName","backspace","delete","down","enter","left","right","space","tab","up","esc","interpolation","globalInterpolation","innerInterpolation","innerFunctionInterpolation","filterMatch","filter2Match","filterNames","func","functionName","substr","_b","_c","_d","_e","_f","Events_1","Bindval_1","conditionalEval","Boolean","createComment","$el","createElement","_i","entries","k","setAttribute","_g","_h","children_1","child","$child","appendChild","HTMLInputElement","_j","vNode","createTextNode"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import { traverse } from \"./dom/Traverse\";\nimport { observe } from \"./data/Observe\";\nimport { possibleEventList } from \"./etc/ElementEvents\";\nimport { renderElem } from \"./vdom/Render\";\n\ntype funcProp = { [key: string]: Function };\n\ninterface PolarbearParams {\n  created?: Function; // Instance created lifecycle hook\n  data?: { [key: string]: any }; // Instance data properties\n  el?: string; // App container element selector\n  events?: funcProp; // Global document events\n  filters?: funcProp; // Content interpolation filters\n  methods?: funcProp; // Instance methods\n  mounted?: Function; // Instance mounted lifecycle hook\n  watch?: funcProp; // Property watchers\n}\n\nexport default class Polarbear {\n  // Root app container selector\n  $appContainerSel: string;\n\n  // Root app container element\n  $appContainerEl: HTMLElement;\n\n  // Virtual dom\n  $vdom: any;\n\n  // References to document elements that are used for edge cases\n  $refs: { [key: string]: Element } = {};\n\n  // Filter functions for use with interpolation elements\n  $filters: funcProp = {};\n\n  // Data properties for instance\n  $data: { [key: string]: any } = {};\n\n  // Property watchers for calling functions on property changes\n  $watchers: { [key: string]: Function } = {};\n\n  // Allows for other instance properties to be created\n  [key: string]: any;\n\n  constructor(params: PolarbearParams) {\n    // Call created method if it exists\n    // Instance has just been created. Nothing else has happened yet\n    if (params.created) params.created();\n\n    // Get app container selector so that it may be continuous referenced for mounting\n    this.$appContainerSel = params.el;\n\n    // Grab root app element\n    this.$appContainerEl = document.querySelector(this.$appContainerSel);\n\n    // Traverse app DOM and copy into VDOM\n    this.$vdom = traverse(this.$appContainerEl);\n\n    // Create observables for all of the data attributes\n    observe(this, params.data);\n\n    // Migrate methods to root level of instance so that they may be easily used\n    if (params.methods) {\n      for (const method in params.methods) {\n        if (params.methods.hasOwnProperty(method)) {\n          // Remap created methods to root level\n          this[method] = params.methods[method];\n        }\n      }\n    }\n\n    // Initialize all document level events if they exist\n    if (params.events) {\n      for (const event in params.events) {\n        if (params.events.hasOwnProperty(event) && possibleEventList.includes(event)) {\n          // Add document level event callbacks for chosen events\n          // TODO: probably change this to be on the app container rather than document\n          document.addEventListener(event, (e: Event) => params.events[event](e));\n        }\n      }\n    }\n\n    // Copy over filter functions into instance\n    if (params.filters) {\n      for (const filter in params.filters) {\n        if (params.filters.hasOwnProperty(filter)) {\n          // Copy filter to the instance\n          this.$filters[filter] = params.filters[filter];\n        }\n      }\n    }\n\n    // Perform initial render\n    this.render();\n\n    // Initialize property watchers\n    if (params.watch) {\n      for (const prop in params.watch) {\n        if (params.watch.hasOwnProperty(prop)) {\n          // Copy the watcher's callback function to the instance\n          this.$watchers[prop] = params.watch[prop];\n        }\n      }\n    }\n\n    // Call mounted method if it exists\n    // Instance has finished generation\n    if (params.mounted) params.mounted.call(this);\n  }\n\n  render() {\n    const r1 = performance.now();\n    // Replace old DOM with newly rendered DOM\n    document.querySelector(this.$appContainerSel)\n            .replaceWith(renderElem(this, this.$vdom));\n    const r2 = performance.now();\n    console.log(`Render took ${(r2-r1).toFixed(1)}ms`)\n  }\n}\n\n(window as any).Polarbear = Polarbear;\n","import Polarbear from \"../Polarbear\";\nimport { setProp } from \"../data/DataFns\";\n\nexport default function computeBinding(instance: Polarbear, prop: string, modifiers: string[]) {\n  // Decide whether to bind the value on the element's input or change event\n  let eventName: string = \"input\";\n  if (modifiers.includes(\"lazy\")) eventName = \"change\";\n\n  // Decide whether to return the element's value as a number\n  let returnAsNumber: boolean = false;\n  if (modifiers.includes(\"number\")) returnAsNumber = true;\n\n  // Decide whether to trim the element's value\n  let trimReturnValue: boolean = false;\n  if (modifiers.includes(\"trim\")) trimReturnValue = true;\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Retrieve element value from event's target element\n      let elementValue: any = (e.target as HTMLInputElement).value;\n\n      // Parse value to number if the bindval has 'number' flag\n      elementValue = returnAsNumber ? isNaN(parseFloat(elementValue)) ? elementValue : parseFloat(elementValue) : elementValue;\n\n      // Trim string if the bindval has 'trim' flag\n      elementValue = trimReturnValue ? elementValue.trim() : elementValue;\n\n      // Update the property on the instance\n      setProp(instance, prop, elementValue);\n    }\n  };\n}\n","import Polarbear from \"../Polarbear\";\nimport { keyCodes } from \"../etc/KeyCodes\";\nimport { possibleEventList } from \"../etc/ElementEvents\";\nimport { parse } from \"../parser/CodeParser\";\n\nexport default function computeEvent(instance: Polarbear, event: string, callbackFn: string): any {\n  // Split raw event into its name and possible modifiers\n  const eventComponents: string[] = event.split(\".\");\n\n  const eventName: string = eventComponents[0];\n  const eventModifiers: string[] = eventComponents.splice(1);\n\n  // Get list of common keys that we want to reference by name instead of keycodes\n  const commonKeyCodeNames: string[] = Object.keys(keyCodes);\n\n  // Get the list of other event modifiers that we want to check for\n  const otherEventModifiers: { [key: string]: boolean } = {\n    \"capture\": false,\n    \"passive\": false,\n    \"prevent\": false,\n    \"once\": false\n  };\n\n  // List of conditional evaluations that will be joined together to check within the event callback\n  let conditionalChecks: (string | number)[] = [];\n\n  // Iterate over event modifiers and compute their responsibility\n  eventModifiers.forEach((em: string) => {\n    if (Object.keys(otherEventModifiers)\n              .includes(em)) {\n      // Change modifier to true if it is a present modifier\n      otherEventModifiers[em] = true;\n    } else if (commonKeyCodeNames.includes(em)) {\n      // Add the resolved key-code value to the conditional checks\n      conditionalChecks.push(`$event.keyCode === ${keyCodes[em]}`);\n    } else {\n      // Attempt to convert the modifier to a number\n      const parsedModifier: number = Number(em);\n      if (!isNaN(parsedModifier)) {\n        // If the modifier is a valid number, add it as a key-code conditional check\n        conditionalChecks.push(`$event.keyCode === ${parsedModifier}`);\n      } else {\n        // If not then just add the literal key value to a key conditional check\n        conditionalChecks.push(`$event.key === '${em}'`);\n      }\n    }\n  });\n\n  // Create a conditional string to evaluate within the function call before evaluating actual code\n  const conditionalRule: string = `if (!(${conditionalChecks.join(\"||\")})) { return; }`;\n\n  // Check for valid event name before attempting to add it to an element\n  if (!possibleEventList.includes(eventName)) {\n    // ERROR: invalid event name\n    return;\n  }\n\n  // Parse the received code into usable code for the event listener\n  const finalCode: string = parse(instance, callbackFn);\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Create strict evaluated function call\n      return Function(`\n      \"use strict\";\n      const $event = arguments[0];\n      ${otherEventModifiers[\"prevent\"] ? `$event.preventDefault();` : \"\"}\n      ${conditionalChecks.length > 0 ? conditionalRule : \"\"}\n      ${finalCode}\n      `)\n        .call(instance, e);\n    },\n    otherEventModifiers\n  };\n}\n","type contiguousObj = { [key: string]: any }\n\n// https://github.com/lukeed/dset\nexport const setProp = (obj: contiguousObj, keys: (string | string[]), val: any): void => {\n  (keys as string).split && (keys = (keys as string).split(\".\"));\n  let i = 0, l = keys.length, t = obj, x;\n  for (; i < l; ++i) {\n    x = t[keys[i]];\n    t = t[keys[i]] = (i === l - 1 ? val : (x != null ? x : (!!~keys[i + 1].indexOf(\".\") || !(+keys[i + 1] > -1)) ? {} : []));\n  }\n};\n\n// https://github.com/developit/dlv\nexport const getProp = (obj: contiguousObj, key: (string | string[]), def?: any, p?: number): any => {\n  p = 0;\n  key = (key as string).split ? (key as string).split(\".\") : key;\n  while (obj && p < key.length) obj = obj[key[p++]];\n  return (obj === undefined || p < key.length) ? def : obj;\n};\n","import Polarbear from \"../Polarbear\";\nimport { getProp, setProp } from \"./DataFns\";\n\nexport const observe = (instance: Polarbear, obj: { [key: string]: any }, parent?: string): void => {\n  for (const prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      // Remap property path if it is a nested property\n      const propPath = parent ? `${parent}.${prop}` : prop;\n\n      // Retrieve property value from its original object\n      const propertyVal = getProp(obj, prop);\n\n      // Get the literal type of the retrieved property\n      const valueType = propertyVal.constructor;\n\n      if (valueType === Object) {\n        // Set property to be empty object since its children will need to be separately observed\n        setProp(instance.$data, propPath, {});\n        setProp(instance, propPath, {});\n\n        // Observe child properties of object\n        observe(instance, propertyVal, propPath);\n      } else if (valueType === Array) {\n        // Store reference array in instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // TODO: update list components if arrays are updated\n\n        const arrProxy = new Proxy(getProp(instance.$data, propPath), {\n          // Proxy trap for value deletion\n          deleteProperty(target: any, property: any): boolean {\n            console.log(`deleting ${String(property)} from ${target}`);\n            return true;\n          },\n          // Proxy trap for updating or adding values\n          set(target: any, property: any, value: any): boolean {\n            target[property] = value;\n            console.log(`${target} ${value} ${String(property)}`);\n            return true;\n          }\n        });\n\n        // Set array proxy to actual root property so that proxy traps are triggered on property reference\n        setProp(instance, propPath, arrProxy);\n      } else {\n        // Store reference property on instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // Set property on root of instance or on child object of instance root\n        const definitionLocation = parent ? getProp(instance, parent) : instance;\n\n        // Define property getters and setters on instance\n        Object.defineProperty(definitionLocation, prop, {\n          get(): any {\n            // Retrieve value from alternative reference so that there is not an infinite loop\n            return getProp(instance.$data, propPath);\n          },\n          set(v: any): void {\n            // Get the property's previous value before reassigning it\n            const oldVal = getProp(instance.$data, propPath);\n            // Set alternative reference so that there is not an infinite loop\n            setProp(instance.$data, propPath, v);\n            // Now that the value has been updated we want to call the watcher if it exists\n            if (instance.$watchers[propPath]) {\n              // Pass through the instance reference and the property's old value and new value\n              instance.$watchers[propPath].apply(instance, [oldVal, v]);\n            }\n            // Update conditionally rendered elements based on property changes\n            // TODO\n            // Call render functions for all components that use the updated property\n            // TODO\n            instance.render();\n          }\n        });\n      }\n    }\n  }\n};\n","import { Regexes } from \"../etc/Regexes\";\nimport { createEl } from \"../vdom/CreateElement\";\nimport { strObj, vNode } from \"../globals\";\n\nexport const traverse = (node: HTMLElement) => {\n  let attrs: strObj = {};\n  let events: strObj = {};\n  let conditionalCase: string = \"\";\n  let boundData: { [key: string]: any } = {};\n  let children: vNode[] = [];\n\n  Array.from(node.childNodes)\n       .forEach((e: HTMLElement) => {\n         if (e.nodeType === 1) {\n           children.push((traverse(e) as vNode));\n         } else {\n           children.push((e as any).data);\n         }\n       });\n\n  for (let i = 0; i < node.attributes.length; i++) {\n    const {name, value} = node.attributes[i];\n\n    if (name.startsWith(\"@\")) {\n      // Process event attributes\n      const ev = name.slice(1);\n      events[ev] = value;\n    } else if (name.startsWith(\"bindval\")) {\n      // Process value binding attribute\n      const specs = name.split(\".\");\n      boundData = {\n        prop: value,\n        opts: specs.slice(1)\n      };\n    } else if (name === \"loopfor\") {\n      // Process loop attribute\n\n    } else if (name === \"ref\") {\n      // Process reference attribute\n\n    } else if (name === \"showif\") {\n      // Process conditional if attribute\n      const computedCondition: string = value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = computedCondition;\n    } else if (name === \"showelse\") {\n      // Process conditional else attribute\n      // @ts-ignore\n      const computedCondition: string = node.previousElementSibling.attributes[\"showif\"].value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = `!(${computedCondition})`;\n    } else {\n      // Found no matching attributes related to Polarbear\n      attrs[name] = value;\n    }\n  }\n\n  return createEl(node.tagName, {\n    attrs,\n    events,\n    conditionalCase,\n    boundData,\n    children\n  });\n};\n","// https://developer.mozilla.org/en-US/docs/Web/Events\nexport const possibleEventList: string[] = [\n  \"input\",\n  \"change\",\n  \"cached\",\n  \"error\",\n  \"abort\",\n  \"load\",\n  \"beforeunload\",\n  \"unload\",\n  \"online\",\n  \"offline\",\n  \"focus\",\n  \"blur\",\n  \"animationstart\",\n  \"animationend\",\n  \"animationiteration\",\n  \"transitionstart\",\n  \"transitioncancel\",\n  \"transitionend\",\n  \"transitionrun\",\n  \"reset\",\n  \"submit\",\n  \"resize\",\n  \"scroll\",\n  \"cut\",\n  \"copy\",\n  \"paste\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mouseenter\",\n  \"mouseover\",\n  \"mousemove\",\n  \"mousedown\",\n  \"mouseup\",\n  \"auxclick\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"wheel\",\n  \"mouseleave\",\n  \"mouseout\",\n  \"select\",\n  \"dragstart\",\n  \"drag\",\n  \"dragend\",\n  \"dragenter\",\n  \"dragover\",\n  \"dragleave\",\n  \"drop\",\n  \"durationchange\",\n  \"loadedmetadata\",\n  \"loadeddata\",\n  \"canplay\",\n  \"canplaythrough\",\n  \"ended\",\n  \"emptied\",\n  \"stalled\",\n  \"suspend\",\n  \"play\",\n  \"playing\",\n  \"pause\",\n  \"waiting\",\n  \"seeking\",\n  \"seeked\",\n  \"ratechange\",\n  \"timeupdate\",\n  \"volumechange\",\n  \"complete\",\n  \"audioprocess\"\n];","// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\nexport const keyCodes: { [key: string]: number } = {\n  \"backspace\": 8,\n  \"delete\": 46,\n  \"down\": 40,\n  \"enter\": 13,\n  \"left\": 37,\n  \"right\": 39,\n  \"space\": 32,\n  \"tab\": 9,\n  \"up\": 38,\n  \"esc\": 27\n};","export namespace Regexes {\n  /*\n   * Matches interpolation content (mustache syntax)\n   *\n   * Input:\n   * `Some content with interpolation content... {{age + 10}}. Some other content {{favColor}}`\n   *\n   * Match:\n   * {{age + 10}}\n   */\n  export const interpolation: RegExp = /({{.*?}})/;\n\n  /*\n   * Matches all mustache syntax interpolation within a string\n   * rather than the first occurrence found\n   *\n   * Input:\n   * `Team 1 score: {{score1}}. Team 2 score: {{score2}}.`\n   *\n   * Matches:\n   * {{score1}}\n   * {{score2}}\n   */\n  export const globalInterpolation: RegExp = /({{.*?}})/g;\n\n  /*\n   * Matches first found property or function inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello\n   */\n  export const innerInterpolation: RegExp = /[\\w\\.]+/;\n\n  /*\n   * Matches only functions in inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello()\n   */\n  export const innerFunctionInterpolation: RegExp = /\\w+\\(\\)/;\n\n  /*\n   * Matches function calls inside interpolation matches\n   *\n   * Input:\n   * `console.log(name + ' is cool. Their age is: ' + age)`\n   *\n   * Matches:\n   * console.log\n   * name\n   * age\n   */\n  export const interpolationContent: RegExp = /[A-z]+((\\.\\w+)+)?(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n\n  /*\n   * Matches filters in interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name | upper | reverse}}`\n   *\n   * Matches:\n   * | upper | reverse\n   */\n  export const filterMatch: RegExp = /(\\|)(\\s+)?\\w+(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filter2Match: RegExp = /(\\|)(\\s+)?\\w+(\\.\\w+)?(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filterNames: RegExp = /\\w+(\\.\\w+)?/g;\n\n  // export const funcParseReg: RegExp = /([$\\w.]+?(?=\\())(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n  // export const propParseReg: RegExp = /\\w+(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n}","import Polarbear from \"../Polarbear\";\nimport { Regexes } from \"../etc/Regexes\";\n\nexport const parse = (instance: Polarbear, code: string): string => {\n  return code.replace(Regexes.innerFunctionInterpolation, (func): string => {\n    // Strip parenthesis from function name to check if the function is in the instance\n    const functionName: string = func.substr(0, func.length - 2);\n\n    if (instance[functionName]) {\n      // Return usable function call if function exists in instance\n      return `this.${func}`;\n    } else {\n      // Return original function call if function is not related to instance\n      return func;\n    }\n  });\n};\n","import { vNodeOpts } from \"../globals\";\n\nexport const createEl = (tagName: string, {attrs = {}, events = {}, conditionalCase = \"\", boundData = {}, children = []}: vNodeOpts) => {\n  return {\n    tagName,\n    attrs,\n    events,\n    conditionalCase,\n    boundData,\n    children\n  };\n};\n","import Polarbear from \"../Polarbear\";\nimport { vNode } from \"../globals\";\nimport computeEvent from \"../attributes/Events\";\nimport { getProp } from \"../data/DataFns\";\nimport computeBinding from \"../attributes/Bindval\";\n\nexport const renderElem = (instance: Polarbear, {tagName, attrs, events, conditionalCase, boundData, children}: vNode) => {\n  // Evaluate conditional statement for the element\n  const conditionalEval: boolean = Boolean(Function(`\"use strict\";return ${conditionalCase};`)\n    .call(instance));\n\n  // Create a comment element if the conditional statement is false\n  if (conditionalCase && conditionalEval === false) {\n    return document.createComment(\" \");\n  }\n\n  // Create a base element with specified tag type\n  const $el = document.createElement(tagName);\n\n  // Add element attributes\n  for (const [k, v] of Object.entries(attrs)) {\n    $el.setAttribute(k, v);\n  }\n\n  // Add element events\n  for (const [k, v] of Object.entries(events)) {\n    const {eventName, fn, otherEventModifiers} = computeEvent(instance, k, v);\n    $el.addEventListener(eventName, fn, otherEventModifiers);\n  }\n\n  // Render and append element children\n  for (const child of children) {\n    const $child = render(instance, child);\n    $el.appendChild($child);\n  }\n\n  if (boundData && $el instanceof HTMLInputElement) {\n    const {prop, opts} = boundData;\n\n    $el.value = getProp(instance, prop);\n\n    const {eventName, fn} = computeBinding(instance, prop, opts);\n    $el.addEventListener(eventName, fn);\n  }\n\n  // Return the created element\n  return $el;\n};\n\nconst render = (instance: Polarbear, vNode: vNode | string) => {\n  if (typeof vNode === \"string\") {\n    return document.createTextNode(vNode);\n  }\n  return renderElem(instance, vNode);\n};\n"]}