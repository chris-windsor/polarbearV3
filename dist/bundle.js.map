{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/Polarbear.ts","src/attributes/Bindval.ts","src/attributes/Events.ts","src/data/DataFns.ts","src/data/Observe.ts","src/dom/Traverse.ts","src/etc/ElementEvents.ts","src/etc/KeyCodes.ts","src/etc/Regexes.ts","src/parser/CodeParser.ts","src/vdom/CreateElement.ts","src/vdom/Hydrate.ts","src/vdom/Patch.ts","src/vdom/Render.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Traverse_1","Observe_1","ElementEvents_1","Render_1","Patch_1","Hydrate_1","Polarbear","prototype","render","r1","performance","now","this","$initial","$currentVDom","default","$masterVDom","$appEl","$node","$target","replaceWith","mount","renderElem","$appContainerEl","temp","patch","r2","console","log","toFixed","params","$refs","$filters","$data","$watchers","created","$appContainerSel","el","document","querySelector","traverse","observe","data","methods","method","hasOwnProperty","events","event_1","possibleEventList","includes","addEventListener","filters","filter","watch","prop","mounted","window","DataFns_1","instance","modifiers","eventName","returnAsNumber","trimReturnValue","fn","elementValue","target","value","isNaN","parseFloat","trim","setProp","KeyCodes_1","CodeParser_1","event","callbackFn","eventComponents","split","eventModifiers","splice","commonKeyCodeNames","Object","keys","keyCodes","otherEventModifiers","capture","passive","prevent","once","conditionalChecks","forEach","em","push","parsedModifier","Number","conditionalRule","join","finalCode","parse","Function","obj","val","x","l","indexOf","getProp","key","def","undefined","parent","propPath_1","propertyVal","valueType","constructor","Array","arrProxy","Proxy","deleteProperty","property","String","set","definitionLocation","defineProperty","get","v","oldVal","apply","Regexes_1","CreateElement_1","node","attrs","conditionalCase","loopCase","boundData","refName","children","from","childNodes","nodeType","attributes","_a","name_1","name","startsWith","slice","opts","replace","Regexes","interpolationContent","s","previousElementSibling","createEl","tagName","backspace","delete","down","enter","left","right","space","tab","up","esc","interpolation","globalInterpolation","innerInterpolation","innerFunctionInterpolation","filterMatch","filter2Match","filterNames","func","functionName","substr","_b","_c","_d","_e","_f","_g","_h","hydrate","nodeCopy","JSON","stringify","toString","parsed","computeContent","content","interpolationMatches","match","cur","diffChildren","oldVChildren","newVChildren","childPatches","oldVChild","diff","additionalPatches","additionalVChild","appendChild","_i","$parent","xs","ys","zipped","Math","max","zip","child","additionalPatches_1","vOldNode","vNewNode","remove","$newNode","patchAttrs","oldAttrs","newAttrs","patches","k","setAttribute","entries","removeAttribute","patches_1","diffAttrs","patchChildren","Events_1","Bindval_1","conditionalEval","Boolean","createComment","$el","createElement","_j","_k","parseInt","loopCaseRenderedChildren","_l","children_1","$child","isArray","HTMLInputElement","_m","vNode","createTextNode"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import { traverse } from \"./dom/Traverse\";\nimport { observe } from \"./data/Observe\";\nimport { possibleEventList } from \"./etc/ElementEvents\";\nimport { renderElem } from \"./vdom/Render\";\nimport diff from \"./vdom/Patch\";\nimport hydrate from \"./vdom/Hydrate\";\n\ntype funcProp = { [key: string]: Function };\n\ninterface PolarbearParams {\n  created?: Function; // Instance created lifecycle hook\n  data?: { [key: string]: any }; // Instance data properties\n  el?: string; // App container element selector\n  events?: funcProp; // Global document events\n  filters?: funcProp; // Content interpolation filters\n  methods?: funcProp; // Instance methods\n  mounted?: Function; // Instance mounted lifecycle hook\n  watch?: funcProp; // Property watchers\n}\n\nexport default class Polarbear {\n  // Root app container selector\n  $appContainerSel: string;\n\n  // Root app container element\n  $appContainerEl: HTMLElement;\n\n  // Virtual dom\n  $masterVDom: any;\n  $currentVDom: any;\n\n  // References to document elements that are used for edge cases\n  $refs: { [key: string]: Element } = {};\n\n  // Filter functions for use with interpolation elements\n  $filters: funcProp = {};\n\n  // Data properties for instance\n  $data: { [key: string]: any } = {};\n\n  // Property watchers for calling functions on property changes\n  $watchers: { [key: string]: Function } = {};\n\n  // Allows for other instance properties to be created\n  [key: string]: any;\n\n  // TODO: remove\n  $initial: boolean = true;\n\n  $appEl: HTMLElement;\n\n  constructor(params: PolarbearParams) {\n    // Call created method if it exists\n    // Instance has just been created. Nothing else has happened yet\n    if (params.created) params.created();\n\n    // Get app container selector so that it may be continuous referenced for mounting\n    this.$appContainerSel = params.el;\n\n    // Grab root app element\n    this.$appContainerEl = document.querySelector(this.$appContainerSel);\n\n    // Traverse app DOM and copy into VDOM\n    this.$masterVDom = traverse(this.$appContainerEl);\n    this.$currentVDom = {};\n\n    // Create observables for all of the data attributes\n    observe(this, params.data);\n\n    // Migrate methods to root level of instance so that they may be easily used\n    if (params.methods) {\n      for (const method in params.methods) {\n        if (params.methods.hasOwnProperty(method)) {\n          // Remap created methods to root level\n          this[method] = params.methods[method];\n        }\n      }\n    }\n\n    // Initialize all document level events if they exist\n    if (params.events) {\n      for (const event in params.events) {\n        if (params.events.hasOwnProperty(event) && possibleEventList.includes(event)) {\n          // Add document level event callbacks for chosen events\n          // TODO: probably change this to be on the app container rather than document\n          document.addEventListener(event, (e: Event) => params.events[event](e));\n        }\n      }\n    }\n\n    // Copy over filter functions into instance\n    if (params.filters) {\n      for (const filter in params.filters) {\n        if (params.filters.hasOwnProperty(filter)) {\n          // Copy filter to the instance\n          this.$filters[filter] = params.filters[filter];\n        }\n      }\n    }\n\n\n    // Perform initial render\n    this.render();\n\n    // Initialize property watchers\n    if (params.watch) {\n      for (const prop in params.watch) {\n        if (params.watch.hasOwnProperty(prop)) {\n          // Copy the watcher's callback function to the instance\n          this.$watchers[prop] = params.watch[prop];\n        }\n      }\n    }\n\n    // Call mounted method if it exists\n    // Instance has finished generation\n    if (params.mounted) params.mounted.call(this);\n  }\n\n  render() {\n    const r1 = performance.now();\n    if (this.$initial) {\n      this.$currentVDom = hydrate(this, this.$masterVDom);\n\n      this.$appEl = mount(renderElem(this, this.$currentVDom), this.$appContainerEl);\n\n      this.$initial = false;\n    } else {\n      const temp = hydrate(this, this.$masterVDom);\n\n      const patch = diff(this, this.$currentVDom, temp);\n\n      this.$appEl = patch(this.$appEl);\n\n      this.$currentVDom = temp;\n    }\n\n    const r2 = performance.now();\n    console.log(`Render took ${(r2 - r1).toFixed(1)}ms`);\n  }\n}\n\nfunction mount($node: HTMLElement, $target: HTMLElement) {\n  $target.replaceWith($node);\n  return $node;\n}\n\n\n(window as any).Polarbear = Polarbear;\n","import Polarbear from \"../Polarbear\";\nimport { setProp } from \"../data/DataFns\";\n\nexport default function computeBinding(instance: Polarbear, prop: string, modifiers: string[]) {\n  // Decide whether to bind the value on the element's input or change event\n  let eventName: string = \"input\";\n  if (modifiers.includes(\"lazy\")) eventName = \"change\";\n\n  // Decide whether to return the element's value as a number\n  let returnAsNumber: boolean = false;\n  if (modifiers.includes(\"number\")) returnAsNumber = true;\n\n  // Decide whether to trim the element's value\n  let trimReturnValue: boolean = false;\n  if (modifiers.includes(\"trim\")) trimReturnValue = true;\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Retrieve element value from event's target element\n      let elementValue: any = (e.target as HTMLInputElement).value;\n\n      // Parse value to number if the bindval has 'number' flag\n      elementValue = returnAsNumber ? isNaN(parseFloat(elementValue)) ? elementValue : parseFloat(elementValue) : elementValue;\n\n      // Trim string if the bindval has 'trim' flag\n      elementValue = trimReturnValue ? elementValue.trim() : elementValue;\n\n      // Update the property on the instance\n      setProp(instance, prop, elementValue);\n    }\n  };\n}\n","import Polarbear from \"../Polarbear\";\nimport { keyCodes } from \"../etc/KeyCodes\";\nimport { possibleEventList } from \"../etc/ElementEvents\";\nimport { parse } from \"../parser/CodeParser\";\n\nexport default function computeEvent(instance: Polarbear, event: string, callbackFn: string): any {\n  // Split raw event into its name and possible modifiers\n  const eventComponents: string[] = event.split(\".\");\n\n  const eventName: string = eventComponents[0];\n  const eventModifiers: string[] = eventComponents.splice(1);\n\n  // Get list of common keys that we want to reference by name instead of keycodes\n  const commonKeyCodeNames: string[] = Object.keys(keyCodes);\n\n  // Get the list of other event modifiers that we want to check for\n  const otherEventModifiers: { [key: string]: boolean } = {\n    \"capture\": false,\n    \"passive\": false,\n    \"prevent\": false,\n    \"once\": false\n  };\n\n  // List of conditional evaluations that will be joined together to check within the event callback\n  let conditionalChecks: (string | number)[] = [];\n\n  // Iterate over event modifiers and compute their responsibility\n  eventModifiers.forEach((em: string) => {\n    if (Object.keys(otherEventModifiers)\n              .includes(em)) {\n      // Change modifier to true if it is a present modifier\n      otherEventModifiers[em] = true;\n    } else if (commonKeyCodeNames.includes(em)) {\n      // Add the resolved key-code value to the conditional checks\n      conditionalChecks.push(`$event.keyCode === ${keyCodes[em]}`);\n    } else {\n      // Attempt to convert the modifier to a number\n      const parsedModifier: number = Number(em);\n      if (!isNaN(parsedModifier)) {\n        // If the modifier is a valid number, add it as a key-code conditional check\n        conditionalChecks.push(`$event.keyCode === ${parsedModifier}`);\n      } else {\n        // If not then just add the literal key value to a key conditional check\n        conditionalChecks.push(`$event.key === '${em}'`);\n      }\n    }\n  });\n\n  // Create a conditional string to evaluate within the function call before evaluating actual code\n  const conditionalRule: string = `if (!(${conditionalChecks.join(\"||\")})) { return; }`;\n\n  // Check for valid event name before attempting to add it to an element\n  if (!possibleEventList.includes(eventName)) {\n    // ERROR: invalid event name\n    return;\n  }\n\n  // Parse the received code into usable code for the event listener\n  const finalCode: string = parse(instance, callbackFn);\n\n  // Return generated event\n  return {\n    eventName,\n    fn: (e: Event) => {\n      // Create strict evaluated function call\n      return Function(`\n      \"use strict\";\n      const $event = arguments[0];\n      ${otherEventModifiers[\"prevent\"] ? `$event.preventDefault();` : \"\"}\n      ${conditionalChecks.length > 0 ? conditionalRule : \"\"}\n      ${finalCode}\n      `)\n        .call(instance, e);\n    },\n    otherEventModifiers\n  };\n}\n","type contiguousObj = { [key: string]: any }\n\n// https://github.com/lukeed/dset\nexport const setProp = (obj: contiguousObj, keys: (string | string[]), val: any): void => {\n  (keys as string).split && (keys = (keys as string).split(\".\"));\n  let i = 0, l = keys.length, t = obj, x;\n  for (; i < l; ++i) {\n    x = t[keys[i]];\n    t = t[keys[i]] = (i === l - 1 ? val : (x != null ? x : (!!~keys[i + 1].indexOf(\".\") || !(+keys[i + 1] > -1)) ? {} : []));\n  }\n};\n\n// https://github.com/developit/dlv\nexport const getProp = (obj: contiguousObj, key: (string | string[]), def?: any, p?: number): any => {\n  p = 0;\n  key = (key as string).split ? (key as string).split(\".\") : key;\n  while (obj && p < key.length) obj = obj[key[p++]];\n  return (obj === undefined || p < key.length) ? def : obj;\n};\n","import Polarbear from \"../Polarbear\";\nimport { getProp, setProp } from \"./DataFns\";\n\nexport const observe = (instance: Polarbear, obj: { [key: string]: any }, parent?: string): void => {\n  for (const prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      // Remap property path if it is a nested property\n      const propPath = parent ? `${parent}.${prop}` : prop;\n\n      // Retrieve property value from its original object\n      const propertyVal = getProp(obj, prop);\n\n      // Get the literal type of the retrieved property\n      const valueType = propertyVal.constructor;\n\n      if (valueType === Object) {\n        // Set property to be empty object since its children will need to be separately observed\n        setProp(instance.$data, propPath, {});\n        setProp(instance, propPath, {});\n\n        // Observe child properties of object\n        observe(instance, propertyVal, propPath);\n      } else if (valueType === Array) {\n        // Store reference array in instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // TODO: update list components if arrays are updated\n\n        const arrProxy = new Proxy(getProp(instance.$data, propPath), {\n          // Proxy trap for value deletion\n          deleteProperty(target: any, property: any): boolean {\n            console.log(`deleting ${String(property)} from ${target}`);\n            return true;\n          },\n          // Proxy trap for updating or adding values\n          set(target: any, property: any, value: any): boolean {\n            target[property] = value;\n            console.log(`${target} ${value} ${String(property)}`);\n            return true;\n          }\n        });\n\n        // Set array proxy to actual root property so that proxy traps are triggered on property reference\n        setProp(instance, propPath, arrProxy);\n      } else {\n        // Store reference property on instance data property\n        setProp(instance.$data, propPath, propertyVal);\n\n        // Set property on root of instance or on child object of instance root\n        const definitionLocation = parent ? getProp(instance, parent) : instance;\n\n        // Define property getters and setters on instance\n        Object.defineProperty(definitionLocation, prop, {\n          get(): any {\n            // Retrieve value from alternative reference so that there is not an infinite loop\n            return getProp(instance.$data, propPath);\n          },\n          set(v: any): void {\n            // Get the property's previous value before reassigning it\n            const oldVal = getProp(instance.$data, propPath);\n            // Set alternative reference so that there is not an infinite loop\n            setProp(instance.$data, propPath, v);\n            // Now that the value has been updated we want to call the watcher if it exists\n            if (instance.$watchers[propPath]) {\n              // Pass through the instance reference and the property's old value and new value\n              instance.$watchers[propPath].apply(instance, [oldVal, v]);\n            }\n            // Update conditionally rendered elements based on property changes\n            // TODO\n            // Call render functions for all components that use the updated property\n            // TODO\n            instance.render();\n          }\n        });\n      }\n    }\n  }\n};\n","import { Regexes } from \"../etc/Regexes\";\nimport { createEl } from \"../vdom/CreateElement\";\nimport { strObj, vNode } from \"../globals\";\n\nexport const traverse = (node: HTMLElement) => {\n  let attrs: strObj = {};\n  let events: strObj = {};\n  let conditionalCase: string = \"\";\n  let loopCase: string = \"\";\n  let boundData: { [key: string]: any } = {};\n  let refName: string = \"\";\n  let children: vNode[] = [];\n\n  Array.from(node.childNodes)\n       .forEach((e: HTMLElement) => {\n         if (e.nodeType === 1) {\n           children.push((traverse(e) as vNode));\n         } else {\n           children.push((e as any).data);\n         }\n       });\n\n  for (let i = 0; i < node.attributes.length; i++) {\n    const {name, value} = node.attributes[i];\n\n    if (name.startsWith(\"@\")) {\n      // Process event attributes\n      const ev = name.slice(1);\n      events[ev] = value;\n    } else if (name.startsWith(\"bindval\")) {\n      // Process value binding attribute\n      const specs = name.split(\".\");\n      boundData = {\n        prop: value,\n        opts: specs.slice(1)\n      };\n    } else if (name === \"loopfor\") {\n      // Process loop attribute\n      loopCase = String(value);\n    } else if (name === \"ref\") {\n      // Process reference attribute\n      refName = String(value);\n    } else if (name === \"showif\") {\n      // Process conditional if attribute\n      const computedCondition: string = value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = computedCondition;\n    } else if (name === \"showelse\") {\n      // Process conditional else attribute\n      // @ts-ignore\n      const computedCondition: string = node.previousElementSibling.attributes[\"showif\"].value.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n      conditionalCase = `!(${computedCondition})`;\n    } else {\n      // Found no matching attributes related to Polarbear\n      attrs[name] = value;\n    }\n  }\n\n  return createEl(node.tagName, {\n    attrs,\n    events,\n    conditionalCase,\n    loopCase,\n    boundData,\n    refName,\n    children\n  });\n};\n","// https://developer.mozilla.org/en-US/docs/Web/Events\nexport const possibleEventList: string[] = [\n  \"input\",\n  \"change\",\n  \"cached\",\n  \"error\",\n  \"abort\",\n  \"load\",\n  \"beforeunload\",\n  \"unload\",\n  \"online\",\n  \"offline\",\n  \"focus\",\n  \"blur\",\n  \"animationstart\",\n  \"animationend\",\n  \"animationiteration\",\n  \"transitionstart\",\n  \"transitioncancel\",\n  \"transitionend\",\n  \"transitionrun\",\n  \"reset\",\n  \"submit\",\n  \"resize\",\n  \"scroll\",\n  \"cut\",\n  \"copy\",\n  \"paste\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mouseenter\",\n  \"mouseover\",\n  \"mousemove\",\n  \"mousedown\",\n  \"mouseup\",\n  \"auxclick\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"wheel\",\n  \"mouseleave\",\n  \"mouseout\",\n  \"select\",\n  \"dragstart\",\n  \"drag\",\n  \"dragend\",\n  \"dragenter\",\n  \"dragover\",\n  \"dragleave\",\n  \"drop\",\n  \"durationchange\",\n  \"loadedmetadata\",\n  \"loadeddata\",\n  \"canplay\",\n  \"canplaythrough\",\n  \"ended\",\n  \"emptied\",\n  \"stalled\",\n  \"suspend\",\n  \"play\",\n  \"playing\",\n  \"pause\",\n  \"waiting\",\n  \"seeking\",\n  \"seeked\",\n  \"ratechange\",\n  \"timeupdate\",\n  \"volumechange\",\n  \"complete\",\n  \"audioprocess\"\n];","// https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\nexport const keyCodes: { [key: string]: number } = {\n  \"backspace\": 8,\n  \"delete\": 46,\n  \"down\": 40,\n  \"enter\": 13,\n  \"left\": 37,\n  \"right\": 39,\n  \"space\": 32,\n  \"tab\": 9,\n  \"up\": 38,\n  \"esc\": 27\n};","export namespace Regexes {\n  /*\n   * Matches interpolation content (mustache syntax)\n   *\n   * Input:\n   * `Some content with interpolation content... {{age + 10}}. Some other content {{favColor}}`\n   *\n   * Match:\n   * {{age + 10}}\n   */\n  export const interpolation: RegExp = /({{.*?}})/;\n\n  /*\n   * Matches all mustache syntax interpolation within a string\n   * rather than the first occurrence found\n   *\n   * Input:\n   * `Team 1 score: {{score1}}. Team 2 score: {{score2}}.`\n   *\n   * Matches:\n   * {{score1}}\n   * {{score2}}\n   */\n  export const globalInterpolation: RegExp = /({{.*?}})/g;\n\n  /*\n   * Matches first found property or function inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello\n   */\n  export const innerInterpolation: RegExp = /[\\w\\.]+/;\n\n  /*\n   * Matches only functions in inside interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name}}`\n   *\n   * Match:\n   * sayHello()\n   */\n  export const innerFunctionInterpolation: RegExp = /\\w+\\(\\)/;\n\n  /*\n   * Matches function calls inside interpolation matches\n   *\n   * Input:\n   * `console.log(name + ' is cool. Their age is: ' + age)`\n   *\n   * Matches:\n   * console.log\n   * name\n   * age\n   */\n  export const interpolationContent: RegExp = /[A-z]+((\\.\\w+)+)?(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n\n  /*\n   * Matches filters in interpolation matches\n   *\n   * Input:\n   * `{{sayHello() + name | upper | reverse}}`\n   *\n   * Matches:\n   * | upper | reverse\n   */\n  export const filterMatch: RegExp = /(\\|)(\\s+)?\\w+(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filter2Match: RegExp = /(\\|)(\\s+)?\\w+(\\.\\w+)?(.*)?\\b(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/;\n  export const filterNames: RegExp = /\\w+(\\.\\w+)?/g;\n\n  // export const funcParseReg: RegExp = /([$\\w.]+?(?=\\())(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n  // export const propParseReg: RegExp = /\\w+(?=([^'\\\\]*(\\\\.|'([^'\\\\]*\\\\.)*[^'\\\\]*'))*[^']*$)/g;\n}","import Polarbear from \"../Polarbear\";\nimport { Regexes } from \"../etc/Regexes\";\n\nexport const parse = (instance: Polarbear, code: string): string => {\n  return code.replace(Regexes.innerFunctionInterpolation, (func): string => {\n    // Strip parenthesis from function name to check if the function is in the instance\n    const functionName: string = func.substr(0, func.length - 2);\n\n    if (instance[functionName]) {\n      // Return usable function call if function exists in instance\n      return `this.${func}`;\n    } else {\n      // Return original function call if function is not related to instance\n      return func;\n    }\n  });\n};\n","import { vNodeOpts } from \"../globals\";\n\nexport const createEl = (tagName: string, {attrs = {}, events = {}, conditionalCase = \"\", loopCase = \"\", boundData = {}, refName = \"\", children = []}: vNodeOpts) => {\n  return {\n    tagName,\n    attrs,\n    events,\n    conditionalCase,\n    loopCase,\n    boundData,\n    refName,\n    children\n  };\n};\n","import { vNode } from \"../globals\";\nimport Polarbear from \"../Polarbear\";\nimport { Regexes } from \"../etc/Regexes\";\n\nexport default function hydrate(instance: Polarbear, node: vNode) {\n  const nodeCopy = JSON.parse(JSON.stringify(node));\n  const data = instance.$data;\n\n  Array.from(nodeCopy.children)\n       .forEach((e: (vNode | string), i: number) => {\n         if ((e).toString() === \"[object Object]\") {\n           nodeCopy.children[i] = hydrate(instance, e as vNode);\n         } else {\n           const parsed = computeContent(instance, e as string);\n\n           nodeCopy.children[i] = Function(`\n            \"use strict\";\n            return \\`${parsed}\\`;\n            `)\n             .call(data);\n         }\n       });\n  return nodeCopy;\n}\n\nconst computeContent = (instance: Polarbear, content: string) => {\n  // Attempt to find interpolation calls within an elements text content\n  const interpolationMatches: RegExpMatchArray = content.match(Regexes.globalInterpolation);\n\n  // If there is no interpolation calls then just break out\n  if (!interpolationMatches) {\n    return content;\n  }\n\n  for (let i = 0; i < interpolationMatches.length; i++) {\n    // Replace every interpolation call with its computed evaluation\n    content = content.replace(interpolationMatches[i], (cur: string) => {\n      // Replace each property or function call within the interpolation with a reference to the instance\n      const innerContent = cur.replace(Regexes.interpolationContent, (s: string) => {\n        // TODO: check for actual property vs built-ins using getter\n        return `this.${s}`;\n      });\n\n      // TODO: fix this nonsense\n      return innerContent.replace('{{', \"${\").replace(\"}}\", \"}\")\n    });\n  }\n\n  return content;\n};\n","import Polarbear from \"../Polarbear\";\nimport { vNode } from \"../globals\";\nimport { render } from \"./Render\";\n\nconst zip = (xs: (vNode | string)[], ys: ((vNode | string)[] | NodeListOf<ChildNode>)) => {\n  const zipped = [];\n  for (let i = 0; i < Math.max(xs.length, ys.length); i++) {\n    zipped.push([xs[i], ys[i]]);\n  }\n  return zipped;\n};\n\nconst diffAttrs = (oldAttrs: {}, newAttrs: {}) => {\n  const patches: any[] = [];\n\n  // set new attributes\n  for (const [k, v] of Object.entries(newAttrs)) {\n    patches.push(($node: HTMLElement) => {\n      $node.setAttribute(k, (v as any));\n      return $node;\n    });\n  }\n\n  // remove old attributes\n  for (const k in oldAttrs) {\n    if (!(k in newAttrs)) {\n      patches.push(($node: HTMLElement) => {\n        $node.removeAttribute(k);\n        return $node;\n      });\n    }\n  }\n\n  return ($node: HTMLElement) => {\n    for (const patch of patches) {\n      patch($node);\n    }\n  };\n};\n\nconst diffChildren = (instance: Polarbear, oldVChildren: (vNode | string)[], newVChildren: (vNode | string)[]) => {\n  const childPatches: any[] = [];\n  oldVChildren.forEach((oldVChild: (vNode | string), i: number) => {\n    childPatches.push(diff(instance, oldVChild, newVChildren[i]));\n  });\n\n  const additionalPatches: any[] = [];\n  for (const additionalVChild of newVChildren.slice(oldVChildren.length)) {\n    additionalPatches.push(($node: HTMLElement) => {\n      $node.appendChild(render(instance, additionalVChild));\n      return $node;\n    });\n  }\n\n  return ($parent: HTMLElement) => {\n    for (const [patch, child] of zip(childPatches, $parent.childNodes)) {\n      if (patch !== undefined && child !== undefined) {\n        (patch as any)(child);\n      }\n    }\n\n    for (const patch of additionalPatches) {\n      patch($parent);\n    }\n\n    return $parent;\n  };\n};\n\nexport default function diff(instance: Polarbear, vOldNode: (vNode | string), vNewNode: (vNode | string)) {\n  if (vNewNode === undefined) {\n    return ($node: HTMLElement): undefined => {\n      $node.remove();\n      return undefined;\n    };\n  }\n\n  if (typeof vOldNode === \"string\" ||\n    typeof vNewNode === \"string\") {\n    if (vOldNode !== vNewNode) {\n      return ($node: HTMLElement) => {\n        const $newNode = render(instance, vNewNode);\n        $node.replaceWith($newNode);\n        return $newNode;\n      };\n    } else {\n      return ($node: HTMLElement): undefined => undefined;\n    }\n  }\n\n  if (vOldNode.tagName !== vNewNode.tagName) {\n    return ($node: HTMLElement) => {\n      const $newNode = render(instance, vNewNode);\n      $node.replaceWith($newNode);\n      return $newNode;\n    };\n  }\n\n  const patchAttrs = diffAttrs(vOldNode.attrs, vNewNode.attrs);\n  const patchChildren = diffChildren(instance, vOldNode.children, vNewNode.children);\n\n  return ($node: HTMLElement) => {\n    if ($node.nodeType === 1) {\n      patchAttrs($node);\n      patchChildren($node);\n    }\n    return $node;\n  };\n};\n","import Polarbear from \"../Polarbear\";\nimport { vNode } from \"../globals\";\nimport computeEvent from \"../attributes/Events\";\nimport { getProp } from \"../data/DataFns\";\nimport computeBinding from \"../attributes/Bindval\";\nimport { createEl } from \"./CreateElement\";\n\nexport const renderElem = (instance: Polarbear, {tagName, attrs = {}, events = {}, conditionalCase, loopCase, boundData, refName, children = []}: vNode): any => {\n  // Evaluate conditional statement for the element\n  const conditionalEval: boolean = Boolean(Function(`\"use strict\";return ${conditionalCase};`)\n    .call(instance));\n\n  // Create a comment element if the conditional statement is false\n  if (conditionalCase && conditionalEval === false) {\n    return document.createComment(\" \");\n  }\n\n  // Create a base element with specified tag type\n  const $el = document.createElement(tagName);\n\n  // Add element attributes\n  for (const [k, v] of Object.entries(attrs)) {\n    $el.setAttribute(k, v);\n  }\n\n  // Add element events\n  for (const [k, v] of Object.entries(events)) {\n    const {eventName, fn, otherEventModifiers} = computeEvent(instance, k, v);\n    $el.addEventListener(eventName, fn, otherEventModifiers);\n  }\n\n  loopCase = loopCase ? parseInt(loopCase as string) : null;\n\n  const loopCaseRenderedChildren: any = [];\n\n  // Render and append element children\n  for (const child of children) {\n    const $child = render(instance, child);\n\n    if (loopCase !== null) {\n      loopCaseRenderedChildren.push(child);\n    } else {\n      if (Array.isArray($child)) {\n        $child.forEach(el => {\n          $el.appendChild(renderElem(instance, el) as HTMLElement);\n        });\n      } else {\n        $el.appendChild($child);\n      }\n    }\n  }\n\n  if (loopCase) {\n    return Array.from(new Array(loopCase), (v, i) => {\n      return createEl(tagName, {\n        attrs,\n        events,\n        conditionalCase,\n        loopCase: null,\n        boundData,\n        refName: null,\n        children: [\n          \"hello\" + i,\n          ...loopCaseRenderedChildren\n        ]\n      });\n    });\n  }\n\n  if (boundData && $el instanceof HTMLInputElement) {\n    const {prop, opts} = boundData;\n\n    $el.value = getProp(instance, prop);\n\n    const {eventName, fn} = computeBinding(instance, prop, opts);\n    $el.addEventListener(eventName, fn);\n  }\n\n  if (refName) {\n    instance.$refs[refName] = $el;\n  }\n\n  // Return the created element\n  return $el;\n};\n\nexport const render = (instance: Polarbear, vNode: vNode | string): any => {\n  if (typeof vNode === \"string\") {\n    return document.createTextNode(vNode);\n  }\n  return renderElem(instance, vNode);\n};\n"]}